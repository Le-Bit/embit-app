/* tslint:disable */
/* eslint-disable */
/**
 * Ombi Api V1
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
import { Configuration } from "../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, RequestArgs, BaseAPI, RequiredError } from "../base";
import { OmbiCoreEngineRequestEngineResult } from "../models";
import { OmbiCoreModelsRequestQuotaCountModel } from "../models";
import { OmbiCoreModelsRequestsDenyMovieModel } from "../models";
import { OmbiCoreModelsRequestsMovieRequestViewModel } from "../models";
import { OmbiCoreModelsRequestsMovieUpdateModel } from "../models";
import { OmbiCoreModelsRequestsRequestCountModel } from "../models";
import { OmbiCoreModelsRequestsTvRequestViewModel } from "../models";
import { OmbiCoreModelsUIRequestsViewModel1OmbiStoreEntitiesRequestsMovieRequestsOmbiStoreVersion3000CultureneutralPublicKeyTokennull } from "../models";
import { OmbiCoreModelsUIRequestsViewModel1OmbiStoreEntitiesRequestsTvRequestsOmbiStoreVersion3000CultureneutralPublicKeyTokennull } from "../models";
import { OmbiModelsDenyTvModel } from "../models";
import { OmbiModelsTvUpdateModel } from "../models";
import { OmbiStoreEntitiesRequestsChildRequests } from "../models";
import { OmbiStoreEntitiesRequestsMovieRequests } from "../models";
import { OmbiStoreEntitiesRequestsTvRequests } from "../models";
/**
 * RequestApi - axios parameter creator
 * @export
 */
export const RequestApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Gets the count of total requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestCountGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes the all movie request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieAllDelete: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/movie/all`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Approves the specified movie request.
     * @param {OmbiCoreModelsRequestsMovieUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieApprovePost: async (
      body?: OmbiCoreModelsRequestsMovieUpdateModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/movie/approve`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set's the specified Movie as available
     * @param {OmbiCoreModelsRequestsMovieUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieAvailablePost: async (
      body?: OmbiCoreModelsRequestsMovieUpdateModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/movie/available`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets movie requests.
     * @param {number} count The count of items you want to return.
     * @param {number} position The position.
     * @param {number} orderType The way we want to order.
     * @param {number} statusType
     * @param {number} availabilityType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieCountPositionOrderTypeStatusTypeAvailabilityTypeGet:
      async (
        count: number,
        position: number,
        orderType: number,
        statusType: number,
        availabilityType: number,
        options: any = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'count' is not null or undefined
        if (count === null || count === undefined) {
          throw new RequiredError(
            "count",
            "Required parameter count was null or undefined when calling apiV1RequestMovieCountPositionOrderTypeStatusTypeAvailabilityTypeGet."
          );
        }
        // verify required parameter 'position' is not null or undefined
        if (position === null || position === undefined) {
          throw new RequiredError(
            "position",
            "Required parameter position was null or undefined when calling apiV1RequestMovieCountPositionOrderTypeStatusTypeAvailabilityTypeGet."
          );
        }
        // verify required parameter 'orderType' is not null or undefined
        if (orderType === null || orderType === undefined) {
          throw new RequiredError(
            "orderType",
            "Required parameter orderType was null or undefined when calling apiV1RequestMovieCountPositionOrderTypeStatusTypeAvailabilityTypeGet."
          );
        }
        // verify required parameter 'statusType' is not null or undefined
        if (statusType === null || statusType === undefined) {
          throw new RequiredError(
            "statusType",
            "Required parameter statusType was null or undefined when calling apiV1RequestMovieCountPositionOrderTypeStatusTypeAvailabilityTypeGet."
          );
        }
        // verify required parameter 'availabilityType' is not null or undefined
        if (availabilityType === null || availabilityType === undefined) {
          throw new RequiredError(
            "availabilityType",
            "Required parameter availabilityType was null or undefined when calling apiV1RequestMovieCountPositionOrderTypeStatusTypeAvailabilityTypeGet."
          );
        }
        const localVarPath =
          `/api/v1/Request/movie/{count}/{position}/{orderType}/{statusType}/{availabilityType}`
            .replace(`{${"count"}}`, encodeURIComponent(String(count)))
            .replace(`{${"position"}}`, encodeURIComponent(String(position)))
            .replace(`{${"orderType"}}`, encodeURIComponent(String(orderType)))
            .replace(
              `{${"statusType"}}`,
              encodeURIComponent(String(statusType))
            )
            .replace(
              `{${"availabilityType"}}`,
              encodeURIComponent(String(availabilityType))
            );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, "https://example.com");
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        const query = new URLSearchParams(localVarUrlObj.search);
        for (const key in localVarQueryParameter) {
          query.set(key, localVarQueryParameter[key]);
        }
        for (const key in options.query) {
          query.set(key, options.query[key]);
        }
        localVarUrlObj.search = new URLSearchParams(query).toString();
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url:
            localVarUrlObj.pathname +
            localVarUrlObj.search +
            localVarUrlObj.hash,
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Denies the specified movie request.
     * @param {OmbiCoreModelsRequestsDenyMovieModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieDenyPut: async (
      body?: OmbiCoreModelsRequestsDenyMovieModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/movie/deny`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all movie requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/movie`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns information about the Single Movie Request
     * @param {number} requestId the movie request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieInfoRequestIdGet: async (
      requestId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling apiV1RequestMovieInfoRequestIdGet."
        );
      }
      const localVarPath = `/api/v1/Request/movie/info/{requestId}`.replace(
        `{${"requestId"}}`,
        encodeURIComponent(String(requestId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Requests a movie.
     * @param {OmbiCoreModelsRequestsMovieRequestViewModel} [body] The movie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMoviePost: async (
      body?: OmbiCoreModelsRequestsMovieRequestViewModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/movie`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates the specified movie request.
     * @param {OmbiStoreEntitiesRequestsMovieRequests} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMoviePut: async (
      body?: OmbiStoreEntitiesRequestsMovieRequests,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/movie`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets model containing remaining number of movie requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieRemainingGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/movie/remaining`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes the specified movie request.
     * @param {number} requestId The request identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieRequestIdDelete: async (
      requestId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling apiV1RequestMovieRequestIdDelete."
        );
      }
      const localVarPath = `/api/v1/Request/movie/{requestId}`.replace(
        `{${"requestId"}}`,
        encodeURIComponent(String(requestId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Searches for a specific movie request
     * @param {string} searchTerm The search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieSearchSearchTermGet: async (
      searchTerm: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchTerm' is not null or undefined
      if (searchTerm === null || searchTerm === undefined) {
        throw new RequiredError(
          "searchTerm",
          "Required parameter searchTerm was null or undefined when calling apiV1RequestMovieSearchSearchTermGet."
        );
      }
      const localVarPath = `/api/v1/Request/movie/search/{searchTerm}`.replace(
        `{${"searchTerm"}}`,
        encodeURIComponent(String(searchTerm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Subscribes for notifications to a movie request
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieSubscribeRequestIdPost: async (
      requestId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling apiV1RequestMovieSubscribeRequestIdPost."
        );
      }
      const localVarPath =
        `/api/v1/Request/movie/subscribe/{requestId}`.replace(
          `{${"requestId"}}`,
          encodeURIComponent(String(requestId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the total amount of movie requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieTotalGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/movie/total`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set's the specified Movie as unavailable
     * @param {OmbiCoreModelsRequestsMovieUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieUnavailablePost: async (
      body?: OmbiCoreModelsRequestsMovieUpdateModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/movie/unavailable`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary UnSubscribes for notifications to a movie request
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieUnsubscribeRequestIdPost: async (
      requestId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling apiV1RequestMovieUnsubscribeRequestIdPost."
        );
      }
      const localVarPath =
        `/api/v1/Request/movie/unsubscribe/{requestId}`.replace(
          `{${"requestId"}}`,
          encodeURIComponent(String(requestId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates the a specific child request
     * @param {OmbiModelsTvUpdateModel} [body] This is the child request&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvApprovePost: async (
      body?: OmbiModelsTvUpdateModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/tv/approve`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set's the specified tv child as available
     * @param {OmbiModelsTvUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvAvailablePost: async (
      body?: OmbiModelsTvUpdateModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/tv/available`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates the a specific child request
     * @param {OmbiStoreEntitiesRequestsChildRequests} [body] The model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvChildPut: async (
      body?: OmbiStoreEntitiesRequestsChildRequests,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/tv/child`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes the a specific tv request
     * @param {number} requestId The model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvChildRequestIdDelete: async (
      requestId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling apiV1RequestTvChildRequestIdDelete."
        );
      }
      const localVarPath = `/api/v1/Request/tv/child/{requestId}`.replace(
        `{${"requestId"}}`,
        encodeURIComponent(String(requestId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the tv requests.
     * @param {number} count The count of items you want to return.
     * @param {number} position The position.
     * @param {number} orderType
     * @param {string} statusFilterType
     * @param {string} availabilityFilterType
     * @param {number} [statusType]
     * @param {number} [availabilityType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet:
      async (
        count: number,
        position: number,
        orderType: number,
        statusFilterType: string,
        availabilityFilterType: string,
        statusType?: number,
        availabilityType?: number,
        options: any = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'count' is not null or undefined
        if (count === null || count === undefined) {
          throw new RequiredError(
            "count",
            "Required parameter count was null or undefined when calling apiV1RequestTvCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet."
          );
        }
        // verify required parameter 'position' is not null or undefined
        if (position === null || position === undefined) {
          throw new RequiredError(
            "position",
            "Required parameter position was null or undefined when calling apiV1RequestTvCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet."
          );
        }
        // verify required parameter 'orderType' is not null or undefined
        if (orderType === null || orderType === undefined) {
          throw new RequiredError(
            "orderType",
            "Required parameter orderType was null or undefined when calling apiV1RequestTvCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet."
          );
        }
        // verify required parameter 'statusFilterType' is not null or undefined
        if (statusFilterType === null || statusFilterType === undefined) {
          throw new RequiredError(
            "statusFilterType",
            "Required parameter statusFilterType was null or undefined when calling apiV1RequestTvCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet."
          );
        }
        // verify required parameter 'availabilityFilterType' is not null or undefined
        if (
          availabilityFilterType === null ||
          availabilityFilterType === undefined
        ) {
          throw new RequiredError(
            "availabilityFilterType",
            "Required parameter availabilityFilterType was null or undefined when calling apiV1RequestTvCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet."
          );
        }
        const localVarPath =
          `/api/v1/Request/tv/{count}/{position}/{orderType}/{statusFilterType}/{availabilityFilterType}`
            .replace(`{${"count"}}`, encodeURIComponent(String(count)))
            .replace(`{${"position"}}`, encodeURIComponent(String(position)))
            .replace(`{${"orderType"}}`, encodeURIComponent(String(orderType)))
            .replace(
              `{${"statusFilterType"}}`,
              encodeURIComponent(String(statusFilterType))
            )
            .replace(
              `{${"availabilityFilterType"}}`,
              encodeURIComponent(String(availabilityFilterType))
            );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, "https://example.com");
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (statusType !== undefined) {
          localVarQueryParameter["statusType"] = statusType;
        }

        if (availabilityType !== undefined) {
          localVarQueryParameter["availabilityType"] = availabilityType;
        }

        const query = new URLSearchParams(localVarUrlObj.search);
        for (const key in localVarQueryParameter) {
          query.set(key, localVarQueryParameter[key]);
        }
        for (const key in options.query) {
          query.set(key, options.query[key]);
        }
        localVarUrlObj.search = new URLSearchParams(query).toString();
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url:
            localVarUrlObj.pathname +
            localVarUrlObj.search +
            localVarUrlObj.hash,
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Denies the a specific child request
     * @param {OmbiModelsDenyTvModel} [body] This is the child request&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvDenyPut: async (
      body?: OmbiModelsDenyTvModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/tv/deny`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the tv requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/tv`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Requests a tv show/episode/season.
     * @param {OmbiCoreModelsRequestsTvRequestViewModel} [body] The tv.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvPost: async (
      body?: OmbiCoreModelsRequestsTvRequestViewModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/tv`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates the a specific tv request
     * @param {OmbiStoreEntitiesRequestsTvRequests} [body] The model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvPut: async (
      body?: OmbiStoreEntitiesRequestsTvRequests,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/tv`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates the quality profile for this tv show
     * @param {number} requestId
     * @param {number} qualityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvQualityRequestIdQualityIdPut: async (
      requestId: number,
      qualityId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling apiV1RequestTvQualityRequestIdQualityIdPut."
        );
      }
      // verify required parameter 'qualityId' is not null or undefined
      if (qualityId === null || qualityId === undefined) {
        throw new RequiredError(
          "qualityId",
          "Required parameter qualityId was null or undefined when calling apiV1RequestTvQualityRequestIdQualityIdPut."
        );
      }
      const localVarPath = `/api/v1/Request/tv/quality/{requestId}/{qualityId}`
        .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)))
        .replace(`{${"qualityId"}}`, encodeURIComponent(String(qualityId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets model containing remaining number of tv requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvRemainingGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/tv/remaining`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retuns all children requests for the request id
     * @param {number} requestId The Request Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvRequestIdChildGet: async (
      requestId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling apiV1RequestTvRequestIdChildGet."
        );
      }
      const localVarPath = `/api/v1/Request/tv/{requestId}/child`.replace(
        `{${"requestId"}}`,
        encodeURIComponent(String(requestId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes the a specific tv request
     * @param {number} requestId The request identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvRequestIdDelete: async (
      requestId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling apiV1RequestTvRequestIdDelete."
        );
      }
      const localVarPath = `/api/v1/Request/tv/{requestId}`.replace(
        `{${"requestId"}}`,
        encodeURIComponent(String(requestId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns the full request object for the specified requestId
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvRequestIdGet: async (
      requestId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling apiV1RequestTvRequestIdGet."
        );
      }
      const localVarPath = `/api/v1/Request/tv/{requestId}`.replace(
        `{${"requestId"}}`,
        encodeURIComponent(String(requestId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates the root path for this tv show
     * @param {number} requestId
     * @param {number} rootFolderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvRootRequestIdRootFolderIdPut: async (
      requestId: number,
      rootFolderId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling apiV1RequestTvRootRequestIdRootFolderIdPut."
        );
      }
      // verify required parameter 'rootFolderId' is not null or undefined
      if (rootFolderId === null || rootFolderId === undefined) {
        throw new RequiredError(
          "rootFolderId",
          "Required parameter rootFolderId was null or undefined when calling apiV1RequestTvRootRequestIdRootFolderIdPut."
        );
      }
      const localVarPath = `/api/v1/Request/tv/root/{requestId}/{rootFolderId}`
        .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)))
        .replace(
          `{${"rootFolderId"}}`,
          encodeURIComponent(String(rootFolderId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Searches for a specific tv request
     * @param {string} searchTerm The search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvSearchSearchTermGet: async (
      searchTerm: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchTerm' is not null or undefined
      if (searchTerm === null || searchTerm === undefined) {
        throw new RequiredError(
          "searchTerm",
          "Required parameter searchTerm was null or undefined when calling apiV1RequestTvSearchSearchTermGet."
        );
      }
      const localVarPath = `/api/v1/Request/tv/search/{searchTerm}`.replace(
        `{${"searchTerm"}}`,
        encodeURIComponent(String(searchTerm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Subscribes for notifications to a TV request
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvSubscribeRequestIdPost: async (
      requestId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling apiV1RequestTvSubscribeRequestIdPost."
        );
      }
      const localVarPath = `/api/v1/Request/tv/subscribe/{requestId}`.replace(
        `{${"requestId"}}`,
        encodeURIComponent(String(requestId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the total amount of TV requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvTotalGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/tv/total`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set's the specified tv child as unavailable
     * @param {OmbiModelsTvUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvUnavailablePost: async (
      body?: OmbiModelsTvUpdateModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/tv/unavailable`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary UnSubscribes for notifications to a TV request
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvUnsubscribeRequestIdPost: async (
      requestId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling apiV1RequestTvUnsubscribeRequestIdPost."
        );
      }
      const localVarPath = `/api/v1/Request/tv/unsubscribe/{requestId}`.replace(
        `{${"requestId"}}`,
        encodeURIComponent(String(requestId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the tv requests lite.
     * @param {number} count The count of items you want to return.
     * @param {number} position The position.
     * @param {number} orderType
     * @param {string} statusFilterType
     * @param {string} availabilityFilterType
     * @param {number} [statusType]
     * @param {number} [availabilityType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvliteCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet:
      async (
        count: number,
        position: number,
        orderType: number,
        statusFilterType: string,
        availabilityFilterType: string,
        statusType?: number,
        availabilityType?: number,
        options: any = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'count' is not null or undefined
        if (count === null || count === undefined) {
          throw new RequiredError(
            "count",
            "Required parameter count was null or undefined when calling apiV1RequestTvliteCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet."
          );
        }
        // verify required parameter 'position' is not null or undefined
        if (position === null || position === undefined) {
          throw new RequiredError(
            "position",
            "Required parameter position was null or undefined when calling apiV1RequestTvliteCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet."
          );
        }
        // verify required parameter 'orderType' is not null or undefined
        if (orderType === null || orderType === undefined) {
          throw new RequiredError(
            "orderType",
            "Required parameter orderType was null or undefined when calling apiV1RequestTvliteCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet."
          );
        }
        // verify required parameter 'statusFilterType' is not null or undefined
        if (statusFilterType === null || statusFilterType === undefined) {
          throw new RequiredError(
            "statusFilterType",
            "Required parameter statusFilterType was null or undefined when calling apiV1RequestTvliteCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet."
          );
        }
        // verify required parameter 'availabilityFilterType' is not null or undefined
        if (
          availabilityFilterType === null ||
          availabilityFilterType === undefined
        ) {
          throw new RequiredError(
            "availabilityFilterType",
            "Required parameter availabilityFilterType was null or undefined when calling apiV1RequestTvliteCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet."
          );
        }
        const localVarPath =
          `/api/v1/Request/tvlite/{count}/{position}/{orderType}/{statusFilterType}/{availabilityFilterType}`
            .replace(`{${"count"}}`, encodeURIComponent(String(count)))
            .replace(`{${"position"}}`, encodeURIComponent(String(position)))
            .replace(`{${"orderType"}}`, encodeURIComponent(String(orderType)))
            .replace(
              `{${"statusFilterType"}}`,
              encodeURIComponent(String(statusFilterType))
            )
            .replace(
              `{${"availabilityFilterType"}}`,
              encodeURIComponent(String(availabilityFilterType))
            );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, "https://example.com");
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (statusType !== undefined) {
          localVarQueryParameter["statusType"] = statusType;
        }

        if (availabilityType !== undefined) {
          localVarQueryParameter["availabilityType"] = availabilityType;
        }

        const query = new URLSearchParams(localVarUrlObj.search);
        for (const key in localVarQueryParameter) {
          query.set(key, localVarQueryParameter[key]);
        }
        for (const key in options.query) {
          query.set(key, options.query[key]);
        }
        localVarUrlObj.search = new URLSearchParams(query).toString();
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url:
            localVarUrlObj.pathname +
            localVarUrlObj.search +
            localVarUrlObj.hash,
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Gets the tv requests without the whole object graph (Does not include seasons/episodes).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvliteGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/tvlite`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Checks if the passed in user has a request
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestUserhasrequestGet: async (
      userId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/Request/userhasrequest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RequestApi - functional programming interface
 * @export
 */
export const RequestApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets the count of total requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestCountGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreModelsRequestsRequestCountModel>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestCountGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Deletes the all movie request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieAllDelete(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieAllDelete(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Approves the specified movie request.
     * @param {OmbiCoreModelsRequestsMovieUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieApprovePost(
      body?: OmbiCoreModelsRequestsMovieUpdateModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieApprovePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Set's the specified Movie as available
     * @param {OmbiCoreModelsRequestsMovieUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieAvailablePost(
      body?: OmbiCoreModelsRequestsMovieUpdateModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieAvailablePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets movie requests.
     * @param {number} count The count of items you want to return.
     * @param {number} position The position.
     * @param {number} orderType The way we want to order.
     * @param {number} statusType
     * @param {number} availabilityType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieCountPositionOrderTypeStatusTypeAvailabilityTypeGet(
      count: number,
      position: number,
      orderType: number,
      statusType: number,
      availabilityType: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreModelsUIRequestsViewModel1OmbiStoreEntitiesRequestsMovieRequestsOmbiStoreVersion3000CultureneutralPublicKeyTokennull>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieCountPositionOrderTypeStatusTypeAvailabilityTypeGet(
        count,
        position,
        orderType,
        statusType,
        availabilityType,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Denies the specified movie request.
     * @param {OmbiCoreModelsRequestsDenyMovieModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieDenyPut(
      body?: OmbiCoreModelsRequestsDenyMovieModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieDenyPut(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets all movie requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OmbiStoreEntitiesRequestsMovieRequests>>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Returns information about the Single Movie Request
     * @param {number} requestId the movie request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieInfoRequestIdGet(
      requestId: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiStoreEntitiesRequestsMovieRequests>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieInfoRequestIdGet(requestId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Requests a movie.
     * @param {OmbiCoreModelsRequestsMovieRequestViewModel} [body] The movie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMoviePost(
      body?: OmbiCoreModelsRequestsMovieRequestViewModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMoviePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Updates the specified movie request.
     * @param {OmbiStoreEntitiesRequestsMovieRequests} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMoviePut(
      body?: OmbiStoreEntitiesRequestsMovieRequests,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiStoreEntitiesRequestsMovieRequests>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMoviePut(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets model containing remaining number of movie requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieRemainingGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreModelsRequestQuotaCountModel>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieRemainingGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Deletes the specified movie request.
     * @param {number} requestId The request identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieRequestIdDelete(
      requestId: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieRequestIdDelete(requestId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Searches for a specific movie request
     * @param {string} searchTerm The search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieSearchSearchTermGet(
      searchTerm: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OmbiStoreEntitiesRequestsMovieRequests>>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieSearchSearchTermGet(searchTerm, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Subscribes for notifications to a movie request
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieSubscribeRequestIdPost(
      requestId: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieSubscribeRequestIdPost(requestId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets the total amount of movie requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieTotalGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieTotalGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Set's the specified Movie as unavailable
     * @param {OmbiCoreModelsRequestsMovieUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieUnavailablePost(
      body?: OmbiCoreModelsRequestsMovieUpdateModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieUnavailablePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary UnSubscribes for notifications to a movie request
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMovieUnsubscribeRequestIdPost(
      requestId: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMovieUnsubscribeRequestIdPost(requestId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Updates the a specific child request
     * @param {OmbiModelsTvUpdateModel} [body] This is the child request&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvApprovePost(
      body?: OmbiModelsTvUpdateModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvApprovePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Set's the specified tv child as available
     * @param {OmbiModelsTvUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvAvailablePost(
      body?: OmbiModelsTvUpdateModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvAvailablePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Updates the a specific child request
     * @param {OmbiStoreEntitiesRequestsChildRequests} [body] The model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvChildPut(
      body?: OmbiStoreEntitiesRequestsChildRequests,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiStoreEntitiesRequestsChildRequests>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvChildPut(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Deletes the a specific tv request
     * @param {number} requestId The model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvChildRequestIdDelete(
      requestId: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvChildRequestIdDelete(requestId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets the tv requests.
     * @param {number} count The count of items you want to return.
     * @param {number} position The position.
     * @param {number} orderType
     * @param {string} statusFilterType
     * @param {string} availabilityFilterType
     * @param {number} [statusType]
     * @param {number} [availabilityType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet(
      count: number,
      position: number,
      orderType: number,
      statusFilterType: string,
      availabilityFilterType: string,
      statusType?: number,
      availabilityType?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreModelsUIRequestsViewModel1OmbiStoreEntitiesRequestsTvRequestsOmbiStoreVersion3000CultureneutralPublicKeyTokennull>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet(
        count,
        position,
        orderType,
        statusFilterType,
        availabilityFilterType,
        statusType,
        availabilityType,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Denies the a specific child request
     * @param {OmbiModelsDenyTvModel} [body] This is the child request&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvDenyPut(
      body?: OmbiModelsDenyTvModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvDenyPut(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets the tv requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OmbiStoreEntitiesRequestsTvRequests>>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Requests a tv show/episode/season.
     * @param {OmbiCoreModelsRequestsTvRequestViewModel} [body] The tv.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvPost(
      body?: OmbiCoreModelsRequestsTvRequestViewModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Updates the a specific tv request
     * @param {OmbiStoreEntitiesRequestsTvRequests} [body] The model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvPut(
      body?: OmbiStoreEntitiesRequestsTvRequests,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiStoreEntitiesRequestsTvRequests>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvPut(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Updates the quality profile for this tv show
     * @param {number} requestId
     * @param {number} qualityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvQualityRequestIdQualityIdPut(
      requestId: number,
      qualityId: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvQualityRequestIdQualityIdPut(
        requestId,
        qualityId,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets model containing remaining number of tv requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvRemainingGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreModelsRequestQuotaCountModel>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvRemainingGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Retuns all children requests for the request id
     * @param {number} requestId The Request Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvRequestIdChildGet(
      requestId: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OmbiStoreEntitiesRequestsChildRequests>>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvRequestIdChildGet(requestId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Deletes the a specific tv request
     * @param {number} requestId The request identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvRequestIdDelete(
      requestId: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvRequestIdDelete(requestId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Returns the full request object for the specified requestId
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvRequestIdGet(
      requestId: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiStoreEntitiesRequestsTvRequests>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvRequestIdGet(requestId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Updates the root path for this tv show
     * @param {number} requestId
     * @param {number} rootFolderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvRootRequestIdRootFolderIdPut(
      requestId: number,
      rootFolderId: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvRootRequestIdRootFolderIdPut(
        requestId,
        rootFolderId,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Searches for a specific tv request
     * @param {string} searchTerm The search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvSearchSearchTermGet(
      searchTerm: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OmbiStoreEntitiesRequestsTvRequests>>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvSearchSearchTermGet(searchTerm, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Subscribes for notifications to a TV request
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvSubscribeRequestIdPost(
      requestId: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvSubscribeRequestIdPost(requestId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets the total amount of TV requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvTotalGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvTotalGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Set's the specified tv child as unavailable
     * @param {OmbiModelsTvUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvUnavailablePost(
      body?: OmbiModelsTvUpdateModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvUnavailablePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary UnSubscribes for notifications to a TV request
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvUnsubscribeRequestIdPost(
      requestId: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvUnsubscribeRequestIdPost(requestId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets the tv requests lite.
     * @param {number} count The count of items you want to return.
     * @param {number} position The position.
     * @param {number} orderType
     * @param {string} statusFilterType
     * @param {string} availabilityFilterType
     * @param {number} [statusType]
     * @param {number} [availabilityType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvliteCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet(
      count: number,
      position: number,
      orderType: number,
      statusFilterType: string,
      availabilityFilterType: string,
      statusType?: number,
      availabilityType?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreModelsUIRequestsViewModel1OmbiStoreEntitiesRequestsTvRequestsOmbiStoreVersion3000CultureneutralPublicKeyTokennull>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvliteCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet(
        count,
        position,
        orderType,
        statusFilterType,
        availabilityFilterType,
        statusType,
        availabilityType,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets the tv requests without the whole object graph (Does not include seasons/episodes).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestTvliteGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OmbiStoreEntitiesRequestsTvRequests>>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestTvliteGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Checks if the passed in user has a request
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestUserhasrequestGet(
      userId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await RequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestUserhasrequestGet(userId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * RequestApi - factory interface
 * @export
 */
export const RequestApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Gets the count of total requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestCountGet(
      options?: any
    ): AxiosPromise<OmbiCoreModelsRequestsRequestCountModel> {
      return RequestApiFp(configuration)
        .apiV1RequestCountGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes the all movie request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieAllDelete(options?: any): AxiosPromise<void> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieAllDelete(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Approves the specified movie request.
     * @param {OmbiCoreModelsRequestsMovieUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieApprovePost(
      body?: OmbiCoreModelsRequestsMovieUpdateModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieApprovePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set's the specified Movie as available
     * @param {OmbiCoreModelsRequestsMovieUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieAvailablePost(
      body?: OmbiCoreModelsRequestsMovieUpdateModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieAvailablePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets movie requests.
     * @param {number} count The count of items you want to return.
     * @param {number} position The position.
     * @param {number} orderType The way we want to order.
     * @param {number} statusType
     * @param {number} availabilityType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieCountPositionOrderTypeStatusTypeAvailabilityTypeGet(
      count: number,
      position: number,
      orderType: number,
      statusType: number,
      availabilityType: number,
      options?: any
    ): AxiosPromise<OmbiCoreModelsUIRequestsViewModel1OmbiStoreEntitiesRequestsMovieRequestsOmbiStoreVersion3000CultureneutralPublicKeyTokennull> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieCountPositionOrderTypeStatusTypeAvailabilityTypeGet(
          count,
          position,
          orderType,
          statusType,
          availabilityType,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Denies the specified movie request.
     * @param {OmbiCoreModelsRequestsDenyMovieModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieDenyPut(
      body?: OmbiCoreModelsRequestsDenyMovieModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieDenyPut(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all movie requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieGet(
      options?: any
    ): AxiosPromise<Array<OmbiStoreEntitiesRequestsMovieRequests>> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns information about the Single Movie Request
     * @param {number} requestId the movie request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieInfoRequestIdGet(
      requestId: number,
      options?: any
    ): AxiosPromise<OmbiStoreEntitiesRequestsMovieRequests> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieInfoRequestIdGet(requestId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Requests a movie.
     * @param {OmbiCoreModelsRequestsMovieRequestViewModel} [body] The movie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMoviePost(
      body?: OmbiCoreModelsRequestsMovieRequestViewModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return RequestApiFp(configuration)
        .apiV1RequestMoviePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates the specified movie request.
     * @param {OmbiStoreEntitiesRequestsMovieRequests} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMoviePut(
      body?: OmbiStoreEntitiesRequestsMovieRequests,
      options?: any
    ): AxiosPromise<OmbiStoreEntitiesRequestsMovieRequests> {
      return RequestApiFp(configuration)
        .apiV1RequestMoviePut(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets model containing remaining number of movie requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieRemainingGet(
      options?: any
    ): AxiosPromise<OmbiCoreModelsRequestQuotaCountModel> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieRemainingGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes the specified movie request.
     * @param {number} requestId The request identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieRequestIdDelete(
      requestId: number,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieRequestIdDelete(requestId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Searches for a specific movie request
     * @param {string} searchTerm The search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieSearchSearchTermGet(
      searchTerm: string,
      options?: any
    ): AxiosPromise<Array<OmbiStoreEntitiesRequestsMovieRequests>> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieSearchSearchTermGet(searchTerm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Subscribes for notifications to a movie request
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieSubscribeRequestIdPost(
      requestId: number,
      options?: any
    ): AxiosPromise<boolean> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieSubscribeRequestIdPost(requestId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets the total amount of movie requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieTotalGet(options?: any): AxiosPromise<number> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieTotalGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set's the specified Movie as unavailable
     * @param {OmbiCoreModelsRequestsMovieUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieUnavailablePost(
      body?: OmbiCoreModelsRequestsMovieUpdateModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieUnavailablePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary UnSubscribes for notifications to a movie request
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMovieUnsubscribeRequestIdPost(
      requestId: number,
      options?: any
    ): AxiosPromise<boolean> {
      return RequestApiFp(configuration)
        .apiV1RequestMovieUnsubscribeRequestIdPost(requestId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates the a specific child request
     * @param {OmbiModelsTvUpdateModel} [body] This is the child request&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvApprovePost(
      body?: OmbiModelsTvUpdateModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return RequestApiFp(configuration)
        .apiV1RequestTvApprovePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set's the specified tv child as available
     * @param {OmbiModelsTvUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvAvailablePost(
      body?: OmbiModelsTvUpdateModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return RequestApiFp(configuration)
        .apiV1RequestTvAvailablePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates the a specific child request
     * @param {OmbiStoreEntitiesRequestsChildRequests} [body] The model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvChildPut(
      body?: OmbiStoreEntitiesRequestsChildRequests,
      options?: any
    ): AxiosPromise<OmbiStoreEntitiesRequestsChildRequests> {
      return RequestApiFp(configuration)
        .apiV1RequestTvChildPut(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes the a specific tv request
     * @param {number} requestId The model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvChildRequestIdDelete(
      requestId: number,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return RequestApiFp(configuration)
        .apiV1RequestTvChildRequestIdDelete(requestId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets the tv requests.
     * @param {number} count The count of items you want to return.
     * @param {number} position The position.
     * @param {number} orderType
     * @param {string} statusFilterType
     * @param {string} availabilityFilterType
     * @param {number} [statusType]
     * @param {number} [availabilityType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet(
      count: number,
      position: number,
      orderType: number,
      statusFilterType: string,
      availabilityFilterType: string,
      statusType?: number,
      availabilityType?: number,
      options?: any
    ): AxiosPromise<OmbiCoreModelsUIRequestsViewModel1OmbiStoreEntitiesRequestsTvRequestsOmbiStoreVersion3000CultureneutralPublicKeyTokennull> {
      return RequestApiFp(configuration)
        .apiV1RequestTvCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet(
          count,
          position,
          orderType,
          statusFilterType,
          availabilityFilterType,
          statusType,
          availabilityType,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Denies the a specific child request
     * @param {OmbiModelsDenyTvModel} [body] This is the child request&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvDenyPut(
      body?: OmbiModelsDenyTvModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return RequestApiFp(configuration)
        .apiV1RequestTvDenyPut(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets the tv requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvGet(
      options?: any
    ): AxiosPromise<Array<OmbiStoreEntitiesRequestsTvRequests>> {
      return RequestApiFp(configuration)
        .apiV1RequestTvGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Requests a tv show/episode/season.
     * @param {OmbiCoreModelsRequestsTvRequestViewModel} [body] The tv.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvPost(
      body?: OmbiCoreModelsRequestsTvRequestViewModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return RequestApiFp(configuration)
        .apiV1RequestTvPost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates the a specific tv request
     * @param {OmbiStoreEntitiesRequestsTvRequests} [body] The model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvPut(
      body?: OmbiStoreEntitiesRequestsTvRequests,
      options?: any
    ): AxiosPromise<OmbiStoreEntitiesRequestsTvRequests> {
      return RequestApiFp(configuration)
        .apiV1RequestTvPut(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates the quality profile for this tv show
     * @param {number} requestId
     * @param {number} qualityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvQualityRequestIdQualityIdPut(
      requestId: number,
      qualityId: number,
      options?: any
    ): AxiosPromise<boolean> {
      return RequestApiFp(configuration)
        .apiV1RequestTvQualityRequestIdQualityIdPut(
          requestId,
          qualityId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets model containing remaining number of tv requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvRemainingGet(
      options?: any
    ): AxiosPromise<OmbiCoreModelsRequestQuotaCountModel> {
      return RequestApiFp(configuration)
        .apiV1RequestTvRemainingGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retuns all children requests for the request id
     * @param {number} requestId The Request Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvRequestIdChildGet(
      requestId: number,
      options?: any
    ): AxiosPromise<Array<OmbiStoreEntitiesRequestsChildRequests>> {
      return RequestApiFp(configuration)
        .apiV1RequestTvRequestIdChildGet(requestId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes the a specific tv request
     * @param {number} requestId The request identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvRequestIdDelete(
      requestId: number,
      options?: any
    ): AxiosPromise<void> {
      return RequestApiFp(configuration)
        .apiV1RequestTvRequestIdDelete(requestId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns the full request object for the specified requestId
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvRequestIdGet(
      requestId: number,
      options?: any
    ): AxiosPromise<OmbiStoreEntitiesRequestsTvRequests> {
      return RequestApiFp(configuration)
        .apiV1RequestTvRequestIdGet(requestId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates the root path for this tv show
     * @param {number} requestId
     * @param {number} rootFolderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvRootRequestIdRootFolderIdPut(
      requestId: number,
      rootFolderId: number,
      options?: any
    ): AxiosPromise<boolean> {
      return RequestApiFp(configuration)
        .apiV1RequestTvRootRequestIdRootFolderIdPut(
          requestId,
          rootFolderId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Searches for a specific tv request
     * @param {string} searchTerm The search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvSearchSearchTermGet(
      searchTerm: string,
      options?: any
    ): AxiosPromise<Array<OmbiStoreEntitiesRequestsTvRequests>> {
      return RequestApiFp(configuration)
        .apiV1RequestTvSearchSearchTermGet(searchTerm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Subscribes for notifications to a TV request
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvSubscribeRequestIdPost(
      requestId: number,
      options?: any
    ): AxiosPromise<boolean> {
      return RequestApiFp(configuration)
        .apiV1RequestTvSubscribeRequestIdPost(requestId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets the total amount of TV requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvTotalGet(options?: any): AxiosPromise<number> {
      return RequestApiFp(configuration)
        .apiV1RequestTvTotalGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set's the specified tv child as unavailable
     * @param {OmbiModelsTvUpdateModel} [body] The Movie&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvUnavailablePost(
      body?: OmbiModelsTvUpdateModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return RequestApiFp(configuration)
        .apiV1RequestTvUnavailablePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary UnSubscribes for notifications to a TV request
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvUnsubscribeRequestIdPost(
      requestId: number,
      options?: any
    ): AxiosPromise<boolean> {
      return RequestApiFp(configuration)
        .apiV1RequestTvUnsubscribeRequestIdPost(requestId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets the tv requests lite.
     * @param {number} count The count of items you want to return.
     * @param {number} position The position.
     * @param {number} orderType
     * @param {string} statusFilterType
     * @param {string} availabilityFilterType
     * @param {number} [statusType]
     * @param {number} [availabilityType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvliteCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet(
      count: number,
      position: number,
      orderType: number,
      statusFilterType: string,
      availabilityFilterType: string,
      statusType?: number,
      availabilityType?: number,
      options?: any
    ): AxiosPromise<OmbiCoreModelsUIRequestsViewModel1OmbiStoreEntitiesRequestsTvRequestsOmbiStoreVersion3000CultureneutralPublicKeyTokennull> {
      return RequestApiFp(configuration)
        .apiV1RequestTvliteCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet(
          count,
          position,
          orderType,
          statusFilterType,
          availabilityFilterType,
          statusType,
          availabilityType,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets the tv requests without the whole object graph (Does not include seasons/episodes).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestTvliteGet(
      options?: any
    ): AxiosPromise<Array<OmbiStoreEntitiesRequestsTvRequests>> {
      return RequestApiFp(configuration)
        .apiV1RequestTvliteGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Checks if the passed in user has a request
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestUserhasrequestGet(
      userId?: string,
      options?: any
    ): AxiosPromise<boolean> {
      return RequestApiFp(configuration)
        .apiV1RequestUserhasrequestGet(userId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RequestApi - object-oriented interface
 * @export
 * @class RequestApi
 * @extends {BaseAPI}
 */
export class RequestApi extends BaseAPI {
  /**
   *
   * @summary Gets the count of total requests
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestCountGet(options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestCountGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Deletes the all movie request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieAllDelete(options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieAllDelete(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Approves the specified movie request.
   * @param {OmbiCoreModelsRequestsMovieUpdateModel} [body] The Movie&#x27;s ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieApprovePost(
    body?: OmbiCoreModelsRequestsMovieUpdateModel,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieApprovePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Set's the specified Movie as available
   * @param {OmbiCoreModelsRequestsMovieUpdateModel} [body] The Movie&#x27;s ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieAvailablePost(
    body?: OmbiCoreModelsRequestsMovieUpdateModel,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieAvailablePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets movie requests.
   * @param {number} count The count of items you want to return.
   * @param {number} position The position.
   * @param {number} orderType The way we want to order.
   * @param {number} statusType
   * @param {number} availabilityType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieCountPositionOrderTypeStatusTypeAvailabilityTypeGet(
    count: number,
    position: number,
    orderType: number,
    statusType: number,
    availabilityType: number,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieCountPositionOrderTypeStatusTypeAvailabilityTypeGet(
        count,
        position,
        orderType,
        statusType,
        availabilityType,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Denies the specified movie request.
   * @param {OmbiCoreModelsRequestsDenyMovieModel} [body] The Movie&#x27;s ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieDenyPut(
    body?: OmbiCoreModelsRequestsDenyMovieModel,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieDenyPut(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets all movie requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieGet(options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Returns information about the Single Movie Request
   * @param {number} requestId the movie request id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieInfoRequestIdGet(requestId: number, options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieInfoRequestIdGet(requestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Requests a movie.
   * @param {OmbiCoreModelsRequestsMovieRequestViewModel} [body] The movie.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMoviePost(
    body?: OmbiCoreModelsRequestsMovieRequestViewModel,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMoviePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Updates the specified movie request.
   * @param {OmbiStoreEntitiesRequestsMovieRequests} [body] The Movie&#x27;s ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMoviePut(
    body?: OmbiStoreEntitiesRequestsMovieRequests,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMoviePut(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets model containing remaining number of movie requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieRemainingGet(options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieRemainingGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Deletes the specified movie request.
   * @param {number} requestId The request identifier.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieRequestIdDelete(requestId: number, options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieRequestIdDelete(requestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Searches for a specific movie request
   * @param {string} searchTerm The search term.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieSearchSearchTermGet(
    searchTerm: string,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieSearchSearchTermGet(searchTerm, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Subscribes for notifications to a movie request
   * @param {number} requestId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieSubscribeRequestIdPost(
    requestId: number,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieSubscribeRequestIdPost(requestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets the total amount of movie requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieTotalGet(options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieTotalGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Set's the specified Movie as unavailable
   * @param {OmbiCoreModelsRequestsMovieUpdateModel} [body] The Movie&#x27;s ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieUnavailablePost(
    body?: OmbiCoreModelsRequestsMovieUpdateModel,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieUnavailablePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary UnSubscribes for notifications to a movie request
   * @param {number} requestId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestMovieUnsubscribeRequestIdPost(
    requestId: number,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestMovieUnsubscribeRequestIdPost(requestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Updates the a specific child request
   * @param {OmbiModelsTvUpdateModel} [body] This is the child request&#x27;s ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvApprovePost(
    body?: OmbiModelsTvUpdateModel,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvApprovePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Set's the specified tv child as available
   * @param {OmbiModelsTvUpdateModel} [body] The Movie&#x27;s ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvAvailablePost(
    body?: OmbiModelsTvUpdateModel,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvAvailablePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Updates the a specific child request
   * @param {OmbiStoreEntitiesRequestsChildRequests} [body] The model.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvChildPut(
    body?: OmbiStoreEntitiesRequestsChildRequests,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvChildPut(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Deletes the a specific tv request
   * @param {number} requestId The model.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvChildRequestIdDelete(requestId: number, options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvChildRequestIdDelete(requestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets the tv requests.
   * @param {number} count The count of items you want to return.
   * @param {number} position The position.
   * @param {number} orderType
   * @param {string} statusFilterType
   * @param {string} availabilityFilterType
   * @param {number} [statusType]
   * @param {number} [availabilityType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet(
    count: number,
    position: number,
    orderType: number,
    statusFilterType: string,
    availabilityFilterType: string,
    statusType?: number,
    availabilityType?: number,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet(
        count,
        position,
        orderType,
        statusFilterType,
        availabilityFilterType,
        statusType,
        availabilityType,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Denies the a specific child request
   * @param {OmbiModelsDenyTvModel} [body] This is the child request&#x27;s ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvDenyPut(body?: OmbiModelsDenyTvModel, options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvDenyPut(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets the tv requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvGet(options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Requests a tv show/episode/season.
   * @param {OmbiCoreModelsRequestsTvRequestViewModel} [body] The tv.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvPost(
    body?: OmbiCoreModelsRequestsTvRequestViewModel,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvPost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Updates the a specific tv request
   * @param {OmbiStoreEntitiesRequestsTvRequests} [body] The model.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvPut(
    body?: OmbiStoreEntitiesRequestsTvRequests,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvPut(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Updates the quality profile for this tv show
   * @param {number} requestId
   * @param {number} qualityId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvQualityRequestIdQualityIdPut(
    requestId: number,
    qualityId: number,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvQualityRequestIdQualityIdPut(requestId, qualityId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets model containing remaining number of tv requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvRemainingGet(options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvRemainingGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Retuns all children requests for the request id
   * @param {number} requestId The Request Id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvRequestIdChildGet(requestId: number, options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvRequestIdChildGet(requestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Deletes the a specific tv request
   * @param {number} requestId The request identifier.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvRequestIdDelete(requestId: number, options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvRequestIdDelete(requestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Returns the full request object for the specified requestId
   * @param {number} requestId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvRequestIdGet(requestId: number, options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvRequestIdGet(requestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Updates the root path for this tv show
   * @param {number} requestId
   * @param {number} rootFolderId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvRootRequestIdRootFolderIdPut(
    requestId: number,
    rootFolderId: number,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvRootRequestIdRootFolderIdPut(
        requestId,
        rootFolderId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Searches for a specific tv request
   * @param {string} searchTerm The search term.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvSearchSearchTermGet(searchTerm: string, options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvSearchSearchTermGet(searchTerm, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Subscribes for notifications to a TV request
   * @param {number} requestId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvSubscribeRequestIdPost(
    requestId: number,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvSubscribeRequestIdPost(requestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets the total amount of TV requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvTotalGet(options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvTotalGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Set's the specified tv child as unavailable
   * @param {OmbiModelsTvUpdateModel} [body] The Movie&#x27;s ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvUnavailablePost(
    body?: OmbiModelsTvUpdateModel,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvUnavailablePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary UnSubscribes for notifications to a TV request
   * @param {number} requestId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvUnsubscribeRequestIdPost(
    requestId: number,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvUnsubscribeRequestIdPost(requestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets the tv requests lite.
   * @param {number} count The count of items you want to return.
   * @param {number} position The position.
   * @param {number} orderType
   * @param {string} statusFilterType
   * @param {string} availabilityFilterType
   * @param {number} [statusType]
   * @param {number} [availabilityType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvliteCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet(
    count: number,
    position: number,
    orderType: number,
    statusFilterType: string,
    availabilityFilterType: string,
    statusType?: number,
    availabilityType?: number,
    options?: any
  ) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvliteCountPositionOrderTypeStatusFilterTypeAvailabilityFilterTypeGet(
        count,
        position,
        orderType,
        statusFilterType,
        availabilityFilterType,
        statusType,
        availabilityType,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets the tv requests without the whole object graph (Does not include seasons/episodes).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestTvliteGet(options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestTvliteGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Checks if the passed in user has a request
   * @param {string} [userId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public apiV1RequestUserhasrequestGet(userId?: string, options?: any) {
    return RequestApiFp(this.configuration)
      .apiV1RequestUserhasrequestGet(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
