/* tslint:disable */
/* eslint-disable */
/**
 * Ombi Api V1
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
import { Configuration } from "../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, RequestArgs, BaseAPI, RequiredError } from "../base";
import { OmbiCoreEngineRequestEngineResult } from "../models";
import { OmbiCoreModelsRequestQuotaCountModel } from "../models";
import { OmbiCoreModelsRequestsAlbumUpdateModel } from "../models";
import { OmbiCoreModelsRequestsDenyAlbumModel } from "../models";
import { OmbiCoreModelsRequestsMusicAlbumRequestViewModel } from "../models";
import { OmbiCoreModelsUIRequestsViewModel1OmbiStoreEntitiesRequestsAlbumRequestOmbiStoreVersion3000CultureneutralPublicKeyTokennull } from "../models";
import { OmbiStoreEntitiesRequestsAlbumRequest } from "../models";
/**
 * MusicRequestApi - axios parameter creator
 * @export
 */
export const MusicRequestApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Approves the specified album request.
     * @param {OmbiCoreModelsRequestsAlbumUpdateModel} [body] The albums&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicApprovePost: async (
      body?: OmbiCoreModelsRequestsAlbumUpdateModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/request/music/approve`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set's the specified album as available
     * @param {OmbiCoreModelsRequestsAlbumUpdateModel} [body] The album&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicAvailablePost: async (
      body?: OmbiCoreModelsRequestsAlbumUpdateModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/request/music/available`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets album requests.
     * @param {number} count The count of items you want to return.
     * @param {number} position The position.
     * @param {number} orderType The way we want to order.
     * @param {number} statusType
     * @param {number} availabilityType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicCountPositionOrderTypeStatusTypeAvailabilityTypeGet:
      async (
        count: number,
        position: number,
        orderType: number,
        statusType: number,
        availabilityType: number,
        options: any = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'count' is not null or undefined
        if (count === null || count === undefined) {
          throw new RequiredError(
            "count",
            "Required parameter count was null or undefined when calling apiV1RequestMusicCountPositionOrderTypeStatusTypeAvailabilityTypeGet."
          );
        }
        // verify required parameter 'position' is not null or undefined
        if (position === null || position === undefined) {
          throw new RequiredError(
            "position",
            "Required parameter position was null or undefined when calling apiV1RequestMusicCountPositionOrderTypeStatusTypeAvailabilityTypeGet."
          );
        }
        // verify required parameter 'orderType' is not null or undefined
        if (orderType === null || orderType === undefined) {
          throw new RequiredError(
            "orderType",
            "Required parameter orderType was null or undefined when calling apiV1RequestMusicCountPositionOrderTypeStatusTypeAvailabilityTypeGet."
          );
        }
        // verify required parameter 'statusType' is not null or undefined
        if (statusType === null || statusType === undefined) {
          throw new RequiredError(
            "statusType",
            "Required parameter statusType was null or undefined when calling apiV1RequestMusicCountPositionOrderTypeStatusTypeAvailabilityTypeGet."
          );
        }
        // verify required parameter 'availabilityType' is not null or undefined
        if (availabilityType === null || availabilityType === undefined) {
          throw new RequiredError(
            "availabilityType",
            "Required parameter availabilityType was null or undefined when calling apiV1RequestMusicCountPositionOrderTypeStatusTypeAvailabilityTypeGet."
          );
        }
        const localVarPath =
          `/api/v1/request/music/{count}/{position}/{orderType}/{statusType}/{availabilityType}`
            .replace(`{${"count"}}`, encodeURIComponent(String(count)))
            .replace(`{${"position"}}`, encodeURIComponent(String(position)))
            .replace(`{${"orderType"}}`, encodeURIComponent(String(orderType)))
            .replace(
              `{${"statusType"}}`,
              encodeURIComponent(String(statusType))
            )
            .replace(
              `{${"availabilityType"}}`,
              encodeURIComponent(String(availabilityType))
            );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, "https://example.com");
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        const query = new URLSearchParams(localVarUrlObj.search);
        for (const key in localVarQueryParameter) {
          query.set(key, localVarQueryParameter[key]);
        }
        for (const key in options.query) {
          query.set(key, options.query[key]);
        }
        localVarUrlObj.search = new URLSearchParams(query).toString();
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url:
            localVarUrlObj.pathname +
            localVarUrlObj.search +
            localVarUrlObj.hash,
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Denies the specified album request.
     * @param {OmbiCoreModelsRequestsDenyAlbumModel} [body] The album&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicDenyPut: async (
      body?: OmbiCoreModelsRequestsDenyAlbumModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/request/music/deny`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all album requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/request/music`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Requests a album.
     * @param {OmbiCoreModelsRequestsMusicAlbumRequestViewModel} [body] The album.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicPost: async (
      body?: OmbiCoreModelsRequestsMusicAlbumRequestViewModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/request/music`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets model containing remaining number of music requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicRemainingGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/request/music/remaining`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes the specified album request.
     * @param {number} requestId The request identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicRequestIdDelete: async (
      requestId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling apiV1RequestMusicRequestIdDelete."
        );
      }
      const localVarPath = `/api/v1/request/music/{requestId}`.replace(
        `{${"requestId"}}`,
        encodeURIComponent(String(requestId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Searches for a specific album request
     * @param {string} searchTerm The search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicSearchSearchTermGet: async (
      searchTerm: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchTerm' is not null or undefined
      if (searchTerm === null || searchTerm === undefined) {
        throw new RequiredError(
          "searchTerm",
          "Required parameter searchTerm was null or undefined when calling apiV1RequestMusicSearchSearchTermGet."
        );
      }
      const localVarPath = `/api/v1/request/music/search/{searchTerm}`.replace(
        `{${"searchTerm"}}`,
        encodeURIComponent(String(searchTerm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the total amount of album requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicTotalGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/request/music/total`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set's the specified album as unavailable
     * @param {OmbiCoreModelsRequestsAlbumUpdateModel} [body] The album&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicUnavailablePost: async (
      body?: OmbiCoreModelsRequestsAlbumUpdateModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/request/music/unavailable`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MusicRequestApi - functional programming interface
 * @export
 */
export const MusicRequestApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Approves the specified album request.
     * @param {OmbiCoreModelsRequestsAlbumUpdateModel} [body] The albums&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMusicApprovePost(
      body?: OmbiCoreModelsRequestsAlbumUpdateModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await MusicRequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMusicApprovePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Set's the specified album as available
     * @param {OmbiCoreModelsRequestsAlbumUpdateModel} [body] The album&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMusicAvailablePost(
      body?: OmbiCoreModelsRequestsAlbumUpdateModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await MusicRequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMusicAvailablePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets album requests.
     * @param {number} count The count of items you want to return.
     * @param {number} position The position.
     * @param {number} orderType The way we want to order.
     * @param {number} statusType
     * @param {number} availabilityType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMusicCountPositionOrderTypeStatusTypeAvailabilityTypeGet(
      count: number,
      position: number,
      orderType: number,
      statusType: number,
      availabilityType: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreModelsUIRequestsViewModel1OmbiStoreEntitiesRequestsAlbumRequestOmbiStoreVersion3000CultureneutralPublicKeyTokennull>
    > {
      const localVarAxiosArgs = await MusicRequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMusicCountPositionOrderTypeStatusTypeAvailabilityTypeGet(
        count,
        position,
        orderType,
        statusType,
        availabilityType,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Denies the specified album request.
     * @param {OmbiCoreModelsRequestsDenyAlbumModel} [body] The album&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMusicDenyPut(
      body?: OmbiCoreModelsRequestsDenyAlbumModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await MusicRequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMusicDenyPut(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets all album requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMusicGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OmbiStoreEntitiesRequestsAlbumRequest>>
    > {
      const localVarAxiosArgs = await MusicRequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMusicGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Requests a album.
     * @param {OmbiCoreModelsRequestsMusicAlbumRequestViewModel} [body] The album.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMusicPost(
      body?: OmbiCoreModelsRequestsMusicAlbumRequestViewModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await MusicRequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMusicPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets model containing remaining number of music requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMusicRemainingGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreModelsRequestQuotaCountModel>
    > {
      const localVarAxiosArgs = await MusicRequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMusicRemainingGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Deletes the specified album request.
     * @param {number} requestId The request identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMusicRequestIdDelete(
      requestId: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await MusicRequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMusicRequestIdDelete(requestId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Searches for a specific album request
     * @param {string} searchTerm The search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMusicSearchSearchTermGet(
      searchTerm: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OmbiStoreEntitiesRequestsAlbumRequest>>
    > {
      const localVarAxiosArgs = await MusicRequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMusicSearchSearchTermGet(searchTerm, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gets the total amount of album requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMusicTotalGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs = await MusicRequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMusicTotalGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Set's the specified album as unavailable
     * @param {OmbiCoreModelsRequestsAlbumUpdateModel} [body] The album&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RequestMusicUnavailablePost(
      body?: OmbiCoreModelsRequestsAlbumUpdateModel,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OmbiCoreEngineRequestEngineResult>
    > {
      const localVarAxiosArgs = await MusicRequestApiAxiosParamCreator(
        configuration
      ).apiV1RequestMusicUnavailablePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * MusicRequestApi - factory interface
 * @export
 */
export const MusicRequestApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Approves the specified album request.
     * @param {OmbiCoreModelsRequestsAlbumUpdateModel} [body] The albums&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicApprovePost(
      body?: OmbiCoreModelsRequestsAlbumUpdateModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return MusicRequestApiFp(configuration)
        .apiV1RequestMusicApprovePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set's the specified album as available
     * @param {OmbiCoreModelsRequestsAlbumUpdateModel} [body] The album&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicAvailablePost(
      body?: OmbiCoreModelsRequestsAlbumUpdateModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return MusicRequestApiFp(configuration)
        .apiV1RequestMusicAvailablePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets album requests.
     * @param {number} count The count of items you want to return.
     * @param {number} position The position.
     * @param {number} orderType The way we want to order.
     * @param {number} statusType
     * @param {number} availabilityType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicCountPositionOrderTypeStatusTypeAvailabilityTypeGet(
      count: number,
      position: number,
      orderType: number,
      statusType: number,
      availabilityType: number,
      options?: any
    ): AxiosPromise<OmbiCoreModelsUIRequestsViewModel1OmbiStoreEntitiesRequestsAlbumRequestOmbiStoreVersion3000CultureneutralPublicKeyTokennull> {
      return MusicRequestApiFp(configuration)
        .apiV1RequestMusicCountPositionOrderTypeStatusTypeAvailabilityTypeGet(
          count,
          position,
          orderType,
          statusType,
          availabilityType,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Denies the specified album request.
     * @param {OmbiCoreModelsRequestsDenyAlbumModel} [body] The album&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicDenyPut(
      body?: OmbiCoreModelsRequestsDenyAlbumModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return MusicRequestApiFp(configuration)
        .apiV1RequestMusicDenyPut(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all album requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicGet(
      options?: any
    ): AxiosPromise<Array<OmbiStoreEntitiesRequestsAlbumRequest>> {
      return MusicRequestApiFp(configuration)
        .apiV1RequestMusicGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Requests a album.
     * @param {OmbiCoreModelsRequestsMusicAlbumRequestViewModel} [body] The album.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicPost(
      body?: OmbiCoreModelsRequestsMusicAlbumRequestViewModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return MusicRequestApiFp(configuration)
        .apiV1RequestMusicPost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets model containing remaining number of music requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicRemainingGet(
      options?: any
    ): AxiosPromise<OmbiCoreModelsRequestQuotaCountModel> {
      return MusicRequestApiFp(configuration)
        .apiV1RequestMusicRemainingGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes the specified album request.
     * @param {number} requestId The request identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicRequestIdDelete(
      requestId: number,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return MusicRequestApiFp(configuration)
        .apiV1RequestMusicRequestIdDelete(requestId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Searches for a specific album request
     * @param {string} searchTerm The search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicSearchSearchTermGet(
      searchTerm: string,
      options?: any
    ): AxiosPromise<Array<OmbiStoreEntitiesRequestsAlbumRequest>> {
      return MusicRequestApiFp(configuration)
        .apiV1RequestMusicSearchSearchTermGet(searchTerm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets the total amount of album requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicTotalGet(options?: any): AxiosPromise<number> {
      return MusicRequestApiFp(configuration)
        .apiV1RequestMusicTotalGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set's the specified album as unavailable
     * @param {OmbiCoreModelsRequestsAlbumUpdateModel} [body] The album&#x27;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RequestMusicUnavailablePost(
      body?: OmbiCoreModelsRequestsAlbumUpdateModel,
      options?: any
    ): AxiosPromise<OmbiCoreEngineRequestEngineResult> {
      return MusicRequestApiFp(configuration)
        .apiV1RequestMusicUnavailablePost(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MusicRequestApi - object-oriented interface
 * @export
 * @class MusicRequestApi
 * @extends {BaseAPI}
 */
export class MusicRequestApi extends BaseAPI {
  /**
   *
   * @summary Approves the specified album request.
   * @param {OmbiCoreModelsRequestsAlbumUpdateModel} [body] The albums&#x27;s ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MusicRequestApi
   */
  public apiV1RequestMusicApprovePost(
    body?: OmbiCoreModelsRequestsAlbumUpdateModel,
    options?: any
  ) {
    return MusicRequestApiFp(this.configuration)
      .apiV1RequestMusicApprovePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Set's the specified album as available
   * @param {OmbiCoreModelsRequestsAlbumUpdateModel} [body] The album&#x27;s ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MusicRequestApi
   */
  public apiV1RequestMusicAvailablePost(
    body?: OmbiCoreModelsRequestsAlbumUpdateModel,
    options?: any
  ) {
    return MusicRequestApiFp(this.configuration)
      .apiV1RequestMusicAvailablePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets album requests.
   * @param {number} count The count of items you want to return.
   * @param {number} position The position.
   * @param {number} orderType The way we want to order.
   * @param {number} statusType
   * @param {number} availabilityType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MusicRequestApi
   */
  public apiV1RequestMusicCountPositionOrderTypeStatusTypeAvailabilityTypeGet(
    count: number,
    position: number,
    orderType: number,
    statusType: number,
    availabilityType: number,
    options?: any
  ) {
    return MusicRequestApiFp(this.configuration)
      .apiV1RequestMusicCountPositionOrderTypeStatusTypeAvailabilityTypeGet(
        count,
        position,
        orderType,
        statusType,
        availabilityType,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Denies the specified album request.
   * @param {OmbiCoreModelsRequestsDenyAlbumModel} [body] The album&#x27;s ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MusicRequestApi
   */
  public apiV1RequestMusicDenyPut(
    body?: OmbiCoreModelsRequestsDenyAlbumModel,
    options?: any
  ) {
    return MusicRequestApiFp(this.configuration)
      .apiV1RequestMusicDenyPut(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets all album requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MusicRequestApi
   */
  public apiV1RequestMusicGet(options?: any) {
    return MusicRequestApiFp(this.configuration)
      .apiV1RequestMusicGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Requests a album.
   * @param {OmbiCoreModelsRequestsMusicAlbumRequestViewModel} [body] The album.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MusicRequestApi
   */
  public apiV1RequestMusicPost(
    body?: OmbiCoreModelsRequestsMusicAlbumRequestViewModel,
    options?: any
  ) {
    return MusicRequestApiFp(this.configuration)
      .apiV1RequestMusicPost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets model containing remaining number of music requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MusicRequestApi
   */
  public apiV1RequestMusicRemainingGet(options?: any) {
    return MusicRequestApiFp(this.configuration)
      .apiV1RequestMusicRemainingGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Deletes the specified album request.
   * @param {number} requestId The request identifier.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MusicRequestApi
   */
  public apiV1RequestMusicRequestIdDelete(requestId: number, options?: any) {
    return MusicRequestApiFp(this.configuration)
      .apiV1RequestMusicRequestIdDelete(requestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Searches for a specific album request
   * @param {string} searchTerm The search term.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MusicRequestApi
   */
  public apiV1RequestMusicSearchSearchTermGet(
    searchTerm: string,
    options?: any
  ) {
    return MusicRequestApiFp(this.configuration)
      .apiV1RequestMusicSearchSearchTermGet(searchTerm, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gets the total amount of album requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MusicRequestApi
   */
  public apiV1RequestMusicTotalGet(options?: any) {
    return MusicRequestApiFp(this.configuration)
      .apiV1RequestMusicTotalGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Set's the specified album as unavailable
   * @param {OmbiCoreModelsRequestsAlbumUpdateModel} [body] The album&#x27;s ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MusicRequestApi
   */
  public apiV1RequestMusicUnavailablePost(
    body?: OmbiCoreModelsRequestsAlbumUpdateModel,
    options?: any
  ) {
    return MusicRequestApiFp(this.configuration)
      .apiV1RequestMusicUnavailablePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
