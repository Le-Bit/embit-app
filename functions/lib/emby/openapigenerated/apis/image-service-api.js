"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageServiceApi = exports.ImageServiceApiFactory = exports.ImageServiceApiFp = exports.ImageServiceApiAxiosParamCreator = void 0;
/* tslint:disable */
/* eslint-disable */
/**
 * Emby Server API
 * Explore the Emby Server API
 *
 * OpenAPI spec version: 4.7.0.17
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("../base");
/**
 * ImageServiceApi - axios parameter creator
 * @export
 */
const ImageServiceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsByIdImagesByType: async (id, type, index, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling deleteItemsByIdImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling deleteItemsByIdImagesByType.");
            }
            const localVarPath = `/Items/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsByIdImagesByTypeByIndex: async (id, type, index, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling deleteItemsByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling deleteItemsByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling deleteItemsByIdImagesByTypeByIndex.");
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByIdImagesByType: async (id, type, index, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling deleteUsersByIdImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling deleteUsersByIdImagesByType.");
            }
            const localVarPath = `/Users/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByIdImagesByTypeByIndex: async (id, type, index, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling deleteUsersByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling deleteUsersByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling deleteUsersByIdImagesByTypeByIndex.");
            }
            const localVarPath = `/Users/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsByNameImagesByType: async (name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling getArtistsByNameImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getArtistsByNameImagesByType.");
            }
            const localVarPath = `/Artists/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsByNameImagesByTypeByIndex: async (name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling getArtistsByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getArtistsByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling getArtistsByNameImagesByTypeByIndex.");
            }
            const localVarPath = `/Artists/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGamegenresByNameImagesByType: async (name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling getGamegenresByNameImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getGamegenresByNameImagesByType.");
            }
            const localVarPath = `/GameGenres/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGamegenresByNameImagesByTypeByIndex: async (name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling getGamegenresByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getGamegenresByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling getGamegenresByNameImagesByTypeByIndex.");
            }
            const localVarPath = `/GameGenres/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenresByNameImagesByType: async (name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling getGenresByNameImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getGenresByNameImagesByType.");
            }
            const localVarPath = `/Genres/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenresByNameImagesByTypeByIndex: async (name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling getGenresByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getGenresByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling getGenresByNameImagesByTypeByIndex.");
            }
            const localVarPath = `/Genres/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets information about an item's images
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImages: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling getItemsByIdImages.");
            }
            const localVarPath = `/Items/{Id}/Images`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImagesByType: async (id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling getItemsByIdImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getItemsByIdImagesByType.");
            }
            const localVarPath = `/Items/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImagesByTypeByIndex: async (id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling getItemsByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getItemsByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling getItemsByIdImagesByTypeByIndex.");
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
         * @param {number} percentPlayed Optional percent to render for the percent played overlay
         * @param {number} unplayedCount Optional unplayed count overlay to render
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount: async (id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new base_1.RequiredError("maxWidth", "Required parameter maxWidth was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new base_1.RequiredError("maxHeight", "Required parameter maxHeight was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new base_1.RequiredError("tag", "Required parameter tag was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new base_1.RequiredError("format", "Required parameter format was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new base_1.RequiredError("percentPlayed", "Required parameter percentPlayed was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new base_1.RequiredError("unplayedCount", "Required parameter unplayedCount was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnplayedCount}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"MaxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"MaxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"Tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"Format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"PercentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"UnplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname +
                    localVarUrlObj.search +
                    localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicgenresByNameImagesByType: async (name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling getMusicgenresByNameImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getMusicgenresByNameImagesByType.");
            }
            const localVarPath = `/MusicGenres/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicgenresByNameImagesByTypeByIndex: async (name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling getMusicgenresByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getMusicgenresByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling getMusicgenresByNameImagesByTypeByIndex.");
            }
            const localVarPath = `/MusicGenres/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonsByNameImagesByType: async (name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling getPersonsByNameImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getPersonsByNameImagesByType.");
            }
            const localVarPath = `/Persons/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonsByNameImagesByTypeByIndex: async (name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling getPersonsByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getPersonsByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling getPersonsByNameImagesByTypeByIndex.");
            }
            const localVarPath = `/Persons/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiosByNameImagesByType: async (name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling getStudiosByNameImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getStudiosByNameImagesByType.");
            }
            const localVarPath = `/Studios/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiosByNameImagesByTypeByIndex: async (name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling getStudiosByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getStudiosByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling getStudiosByNameImagesByTypeByIndex.");
            }
            const localVarPath = `/Studios/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByIdImagesByType: async (id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling getUsersByIdImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getUsersByIdImagesByType.");
            }
            const localVarPath = `/Users/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByIdImagesByTypeByIndex: async (id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling getUsersByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling getUsersByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling getUsersByIdImagesByTypeByIndex.");
            }
            const localVarPath = `/Users/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistsByNameImagesByType: async (name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling headArtistsByNameImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headArtistsByNameImagesByType.");
            }
            const localVarPath = `/Artists/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistsByNameImagesByTypeByIndex: async (name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling headArtistsByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headArtistsByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling headArtistsByNameImagesByTypeByIndex.");
            }
            const localVarPath = `/Artists/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGamegenresByNameImagesByType: async (name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling headGamegenresByNameImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headGamegenresByNameImagesByType.");
            }
            const localVarPath = `/GameGenres/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGamegenresByNameImagesByTypeByIndex: async (name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling headGamegenresByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headGamegenresByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling headGamegenresByNameImagesByTypeByIndex.");
            }
            const localVarPath = `/GameGenres/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenresByNameImagesByType: async (name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling headGenresByNameImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headGenresByNameImagesByType.");
            }
            const localVarPath = `/Genres/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenresByNameImagesByTypeByIndex: async (name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling headGenresByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headGenresByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling headGenresByNameImagesByTypeByIndex.");
            }
            const localVarPath = `/Genres/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemsByIdImagesByType: async (id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling headItemsByIdImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headItemsByIdImagesByType.");
            }
            const localVarPath = `/Items/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemsByIdImagesByTypeByIndex: async (id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling headItemsByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headItemsByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling headItemsByIdImagesByTypeByIndex.");
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
         * @param {number} percentPlayed Optional percent to render for the percent played overlay
         * @param {number} unplayedCount Optional unplayed count overlay to render
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount: async (id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new base_1.RequiredError("maxWidth", "Required parameter maxWidth was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new base_1.RequiredError("maxHeight", "Required parameter maxHeight was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new base_1.RequiredError("tag", "Required parameter tag was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new base_1.RequiredError("format", "Required parameter format was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new base_1.RequiredError("percentPlayed", "Required parameter percentPlayed was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new base_1.RequiredError("unplayedCount", "Required parameter unplayedCount was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.");
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnplayedCount}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"MaxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"MaxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"Tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"Format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"PercentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"UnplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname +
                    localVarUrlObj.search +
                    localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicgenresByNameImagesByType: async (name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling headMusicgenresByNameImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headMusicgenresByNameImagesByType.");
            }
            const localVarPath = `/MusicGenres/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicgenresByNameImagesByTypeByIndex: async (name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling headMusicgenresByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headMusicgenresByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling headMusicgenresByNameImagesByTypeByIndex.");
            }
            const localVarPath = `/MusicGenres/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonsByNameImagesByType: async (name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling headPersonsByNameImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headPersonsByNameImagesByType.");
            }
            const localVarPath = `/Persons/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonsByNameImagesByTypeByIndex: async (name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling headPersonsByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headPersonsByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling headPersonsByNameImagesByTypeByIndex.");
            }
            const localVarPath = `/Persons/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudiosByNameImagesByType: async (name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling headStudiosByNameImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headStudiosByNameImagesByType.");
            }
            const localVarPath = `/Studios/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudiosByNameImagesByTypeByIndex: async (name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError("name", "Required parameter name was null or undefined when calling headStudiosByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headStudiosByNameImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling headStudiosByNameImagesByTypeByIndex.");
            }
            const localVarPath = `/Studios/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUsersByIdImagesByType: async (id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling headUsersByIdImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headUsersByIdImagesByType.");
            }
            const localVarPath = `/Users/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUsersByIdImagesByTypeByIndex: async (id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling headUsersByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling headUsersByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling headUsersByIdImagesByTypeByIndex.");
            }
            const localVarPath = `/Users/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (maxWidth !== undefined) {
                localVarQueryParameter["MaxWidth"] = maxWidth;
            }
            if (maxHeight !== undefined) {
                localVarQueryParameter["MaxHeight"] = maxHeight;
            }
            if (width !== undefined) {
                localVarQueryParameter["Width"] = width;
            }
            if (height !== undefined) {
                localVarQueryParameter["Height"] = height;
            }
            if (quality !== undefined) {
                localVarQueryParameter["Quality"] = quality;
            }
            if (tag !== undefined) {
                localVarQueryParameter["Tag"] = tag;
            }
            if (cropWhitespace !== undefined) {
                localVarQueryParameter["CropWhitespace"] = cropWhitespace;
            }
            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter["EnableImageEnhancers"] = enableImageEnhancers;
            }
            if (format !== undefined) {
                localVarQueryParameter["Format"] = format;
            }
            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter["AddPlayedIndicator"] = addPlayedIndicator;
            }
            if (percentPlayed !== undefined) {
                localVarQueryParameter["PercentPlayed"] = percentPlayed;
            }
            if (unplayedCount !== undefined) {
                localVarQueryParameter["UnplayedCount"] = unplayedCount;
            }
            if (backgroundColor !== undefined) {
                localVarQueryParameter["BackgroundColor"] = backgroundColor;
            }
            if (foregroundLayer !== undefined) {
                localVarQueryParameter["ForegroundLayer"] = foregroundLayer;
            }
            if (autoOrient !== undefined) {
                localVarQueryParameter["AutoOrient"] = autoOrient;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Uploads an image for an item, must be base64 encoded.
         * @param {Object} body Binary stream
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByType: async (body, id, type, index, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postItemsByIdImagesByType.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postItemsByIdImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling postItemsByIdImagesByType.");
            }
            const localVarPath = `/Items/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            localVarHeaderParameter["Content-Type"] = "application/octet-stream";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Uploads an image for an item, must be base64 encoded.
         * @param {Object} body Binary stream
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByTypeByIndex: async (body, id, type, index, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postItemsByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postItemsByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling postItemsByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling postItemsByIdImagesByTypeByIndex.");
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/octet-stream";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Updates the index for an item image
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} newIndex The new image index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByTypeByIndexIndex: async (id, type, index, newIndex, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postItemsByIdImagesByTypeByIndexIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling postItemsByIdImagesByTypeByIndexIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling postItemsByIdImagesByTypeByIndexIndex.");
            }
            // verify required parameter 'newIndex' is not null or undefined
            if (newIndex === null || newIndex === undefined) {
                throw new base_1.RequiredError("newIndex", "Required parameter newIndex was null or undefined when calling postItemsByIdImagesByTypeByIndexIndex.");
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}/Index`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (newIndex !== undefined) {
                localVarQueryParameter["NewIndex"] = newIndex;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Updates the index for an item image
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {string} url The url for the new image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByTypeByIndexUrl: async (id, type, index, url, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postItemsByIdImagesByTypeByIndexUrl.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling postItemsByIdImagesByTypeByIndexUrl.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling postItemsByIdImagesByTypeByIndexUrl.");
            }
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new base_1.RequiredError("url", "Required parameter url was null or undefined when calling postItemsByIdImagesByTypeByIndexUrl.");
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}/Url`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (url !== undefined) {
                localVarQueryParameter["Url"] = url;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Uploads an image for an item, must be base64 encoded.
         * @param {Object} body Binary stream
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByIdImagesByType: async (body, id, type, index, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postUsersByIdImagesByType.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postUsersByIdImagesByType.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling postUsersByIdImagesByType.");
            }
            const localVarPath = `/Users/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (index !== undefined) {
                localVarQueryParameter["Index"] = index;
            }
            localVarHeaderParameter["Content-Type"] = "application/octet-stream";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Uploads an image for an item, must be base64 encoded.
         * @param {Object} body Binary stream
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByIdImagesByTypeByIndex: async (body, id, type, index, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postUsersByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postUsersByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError("type", "Required parameter type was null or undefined when calling postUsersByIdImagesByTypeByIndex.");
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError("index", "Required parameter index was null or undefined when calling postUsersByIdImagesByTypeByIndex.");
            }
            const localVarPath = `/Users/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/octet-stream";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ImageServiceApiAxiosParamCreator = ImageServiceApiAxiosParamCreator;
/**
 * ImageServiceApi - functional programming interface
 * @export
 */
const ImageServiceApiFp = function (configuration) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemsByIdImagesByType(id, type, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).deleteItemsByIdImagesByType(id, type, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemsByIdImagesByTypeByIndex(id, type, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).deleteItemsByIdImagesByTypeByIndex(id, type, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersByIdImagesByType(id, type, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).deleteUsersByIdImagesByType(id, type, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersByIdImagesByTypeByIndex(id, type, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).deleteUsersByIdImagesByTypeByIndex(id, type, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets information about an item's images
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdImages(id, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getItemsByIdImages(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
         * @param {number} percentPlayed Optional percent to render for the percent played overlay
         * @param {number} unplayedCount Optional unplayed count overlay to render
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).getUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
         * @param {number} percentPlayed Optional percent to render for the percent played overlay
         * @param {number} unplayedCount Optional unplayed count overlay to render
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).headUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Uploads an image for an item, must be base64 encoded.
         * @param {Object} body Binary stream
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postItemsByIdImagesByType(body, id, type, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).postItemsByIdImagesByType(body, id, type, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Uploads an image for an item, must be base64 encoded.
         * @param {Object} body Binary stream
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postItemsByIdImagesByTypeByIndex(body, id, type, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).postItemsByIdImagesByTypeByIndex(body, id, type, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Updates the index for an item image
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} newIndex The new image index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postItemsByIdImagesByTypeByIndexIndex(id, type, index, newIndex, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).postItemsByIdImagesByTypeByIndexIndex(id, type, index, newIndex, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Updates the index for an item image
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {string} url The url for the new image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postItemsByIdImagesByTypeByIndexUrl(id, type, index, url, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).postItemsByIdImagesByTypeByIndexUrl(id, type, index, url, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Uploads an image for an item, must be base64 encoded.
         * @param {Object} body Binary stream
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersByIdImagesByType(body, id, type, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).postUsersByIdImagesByType(body, id, type, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Uploads an image for an item, must be base64 encoded.
         * @param {Object} body Binary stream
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersByIdImagesByTypeByIndex(body, id, type, index, options) {
            const localVarAxiosArgs = await (0, exports.ImageServiceApiAxiosParamCreator)(configuration).postUsersByIdImagesByTypeByIndex(body, id, type, index, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
exports.ImageServiceApiFp = ImageServiceApiFp;
/**
 * ImageServiceApi - factory interface
 * @export
 */
const ImageServiceApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsByIdImagesByType(id, type, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .deleteItemsByIdImagesByType(id, type, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsByIdImagesByTypeByIndex(id, type, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .deleteItemsByIdImagesByTypeByIndex(id, type, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByIdImagesByType(id, type, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .deleteUsersByIdImagesByType(id, type, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByIdImagesByTypeByIndex(id, type, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .deleteUsersByIdImagesByTypeByIndex(id, type, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets information about an item's images
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImages(id, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getItemsByIdImages(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
         * @param {number} percentPlayed Optional percent to render for the percent played overlay
         * @param {number} unplayedCount Optional unplayed count overlay to render
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .getUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
         * @param {number} percentPlayed Optional percent to render for the percent played overlay
         * @param {number} unplayedCount Optional unplayed count overlay to render
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .headUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Uploads an image for an item, must be base64 encoded.
         * @param {Object} body Binary stream
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByType(body, id, type, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .postItemsByIdImagesByType(body, id, type, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Uploads an image for an item, must be base64 encoded.
         * @param {Object} body Binary stream
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByTypeByIndex(body, id, type, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .postItemsByIdImagesByTypeByIndex(body, id, type, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Updates the index for an item image
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} newIndex The new image index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByTypeByIndexIndex(id, type, index, newIndex, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .postItemsByIdImagesByTypeByIndexIndex(id, type, index, newIndex, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Updates the index for an item image
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {string} url The url for the new image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByTypeByIndexUrl(id, type, index, url, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .postItemsByIdImagesByTypeByIndexUrl(id, type, index, url, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Uploads an image for an item, must be base64 encoded.
         * @param {Object} body Binary stream
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByIdImagesByType(body, id, type, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .postUsersByIdImagesByType(body, id, type, index, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Uploads an image for an item, must be base64 encoded.
         * @param {Object} body Binary stream
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByIdImagesByTypeByIndex(body, id, type, index, options) {
            return (0, exports.ImageServiceApiFp)(configuration)
                .postUsersByIdImagesByTypeByIndex(body, id, type, index, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.ImageServiceApiFactory = ImageServiceApiFactory;
/**
 * ImageServiceApi - object-oriented interface
 * @export
 * @class ImageServiceApi
 * @extends {BaseAPI}
 */
class ImageServiceApi extends base_1.BaseAPI {
    /**
     * Requires authentication as administrator
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    deleteItemsByIdImagesByType(id, type, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .deleteItemsByIdImagesByType(id, type, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    deleteItemsByIdImagesByTypeByIndex(id, type, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .deleteItemsByIdImagesByTypeByIndex(id, type, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    deleteUsersByIdImagesByType(id, type, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .deleteUsersByIdImagesByType(id, type, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    deleteUsersByIdImagesByTypeByIndex(id, type, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .deleteUsersByIdImagesByTypeByIndex(id, type, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets information about an item's images
     * @param {string} id Item Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getItemsByIdImages(id, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getItemsByIdImages(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id Item Id
     * @param {number} maxWidth The maximum image width to return.
     * @param {number} maxHeight The maximum image height to return.
     * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
     * @param {number} percentPlayed Optional percent to render for the percent played overlay
     * @param {number} unplayedCount Optional unplayed count overlay to render
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    getUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .getUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id Item Id
     * @param {number} maxWidth The maximum image width to return.
     * @param {number} maxHeight The maximum image height to return.
     * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
     * @param {number} percentPlayed Optional percent to render for the percent played overlay
     * @param {number} unplayedCount Optional unplayed count overlay to render
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {boolean} [autoOrient] Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    headUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .headUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, autoOrient, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Uploads an image for an item, must be base64 encoded.
     * @param {Object} body Binary stream
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    postItemsByIdImagesByType(body, id, type, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .postItemsByIdImagesByType(body, id, type, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Uploads an image for an item, must be base64 encoded.
     * @param {Object} body Binary stream
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    postItemsByIdImagesByTypeByIndex(body, id, type, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .postItemsByIdImagesByTypeByIndex(body, id, type, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Updates the index for an item image
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} newIndex The new image index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    postItemsByIdImagesByTypeByIndexIndex(id, type, index, newIndex, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .postItemsByIdImagesByTypeByIndexIndex(id, type, index, newIndex, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Updates the index for an item image
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {string} url The url for the new image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    postItemsByIdImagesByTypeByIndexUrl(id, type, index, url, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .postItemsByIdImagesByTypeByIndexUrl(id, type, index, url, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Uploads an image for an item, must be base64 encoded.
     * @param {Object} body Binary stream
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    postUsersByIdImagesByType(body, id, type, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .postUsersByIdImagesByType(body, id, type, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Uploads an image for an item, must be base64 encoded.
     * @param {Object} body Binary stream
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    postUsersByIdImagesByTypeByIndex(body, id, type, index, options) {
        return (0, exports.ImageServiceApiFp)(this.configuration)
            .postUsersByIdImagesByTypeByIndex(body, id, type, index, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.ImageServiceApi = ImageServiceApi;
//# sourceMappingURL=image-service-api.js.map