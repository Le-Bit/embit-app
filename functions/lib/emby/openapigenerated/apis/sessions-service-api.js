"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionsServiceApi = exports.SessionsServiceApiFactory = exports.SessionsServiceApiFp = exports.SessionsServiceApiAxiosParamCreator = void 0;
/* tslint:disable */
/* eslint-disable */
/**
 * Emby Server API
 * Explore the Emby Server API
 *
 * OpenAPI spec version: 4.7.0.17
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("../base");
/**
 * SessionsServiceApi - axios parameter creator
 * @export
 */
const SessionsServiceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} key Auth Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthKeysByKey: async (key, options = {}) => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new base_1.RequiredError("key", "Required parameter key was null or undefined when calling deleteAuthKeysByKey.");
            }
            const localVarPath = `/Auth/Keys/{Key}`.replace(`{${"Key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Removes an additional user from a session
         * @param {string} id Session Id
         * @param {string} userId UserId Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionsByIdUsersByUserid: async (id, userId, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling deleteSessionsByIdUsersByUserid.");
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError("userId", "Required parameter userId was null or undefined when calling deleteSessionsByIdUsersByUserid.");
            }
            const localVarPath = `/Sessions/{Id}/Users/{UserId}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthKeys: async (startIndex, limit, options = {}) => {
            const localVarPath = `/Auth/Keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (startIndex !== undefined) {
                localVarQueryParameter["StartIndex"] = startIndex;
            }
            if (limit !== undefined) {
                localVarQueryParameter["Limit"] = limit;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProviders: async (options = {}) => {
            const localVarPath = `/Auth/Providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a list of sessions
         * @param {string} [controllableByUserId] Optional. Filter by sessions that a given user is allowed to remote control.
         * @param {string} [deviceId] Optional. Filter by device id.
         * @param {string} [id] Optional. Filter by session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (controllableByUserId, deviceId, id, options = {}) => {
            const localVarPath = `/Sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (controllableByUserId !== undefined) {
                localVarQueryParameter["ControllableByUserId"] = controllableByUserId;
            }
            if (deviceId !== undefined) {
                localVarQueryParameter["DeviceId"] = deviceId;
            }
            if (id !== undefined) {
                localVarQueryParameter["Id"] = id;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a the current play queue from a session
         * @param {string} [id] Optional. Filter by session id.
         * @param {string} [deviceId] Optional. Filter by device id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsPlayqueue: async (id, deviceId, options = {}) => {
            const localVarPath = `/Sessions/PlayQueue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (id !== undefined) {
                localVarQueryParameter["Id"] = id;
            }
            if (deviceId !== undefined) {
                localVarQueryParameter["DeviceId"] = deviceId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} app App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthKeys: async (app, options = {}) => {
            // verify required parameter 'app' is not null or undefined
            if (app === null || app === undefined) {
                throw new base_1.RequiredError("app", "Required parameter app was null or undefined when calling postAuthKeys.");
            }
            const localVarPath = `/Auth/Keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (app !== undefined) {
                localVarQueryParameter["App"] = app;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {GeneralCommand} body GeneralCommand:
         * @param {string} id Session Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdCommand: async (body, id, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postSessionsByIdCommand.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postSessionsByIdCommand.");
            }
            const localVarPath = `/Sessions/{Id}/Command`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {string} id Session Id
         * @param {string} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdCommandByCommand: async (id, command, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postSessionsByIdCommandByCommand.");
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new base_1.RequiredError("command", "Required parameter command was null or undefined when calling postSessionsByIdCommandByCommand.");
            }
            const localVarPath = `/Sessions/{Id}/Command/{Command}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a command to a client to display a message to the user
         * @param {string} id Session Id
         * @param {string} text The message text.
         * @param {string} header The message header.
         * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdMessage: async (id, text, header, timeoutMs, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postSessionsByIdMessage.");
            }
            // verify required parameter 'text' is not null or undefined
            if (text === null || text === undefined) {
                throw new base_1.RequiredError("text", "Required parameter text was null or undefined when calling postSessionsByIdMessage.");
            }
            // verify required parameter 'header' is not null or undefined
            if (header === null || header === undefined) {
                throw new base_1.RequiredError("header", "Required parameter header was null or undefined when calling postSessionsByIdMessage.");
            }
            const localVarPath = `/Sessions/{Id}/Message`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (text !== undefined) {
                localVarQueryParameter["Text"] = text;
            }
            if (header !== undefined) {
                localVarQueryParameter["Header"] = header;
            }
            if (timeoutMs !== undefined) {
                localVarQueryParameter["TimeoutMs"] = timeoutMs;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Instructs a session to play an item
         * @param {PlayRequest} body PlayRequest:
         * @param {Array&lt;number&gt;} itemIds The ids of the items to play, comma delimited
         * @param {string} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
         * @param {string} id Session Id
         * @param {number} [startPositionTicks] The starting position of the first item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdPlaying: async (body, itemIds, playCommand, id, startPositionTicks, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postSessionsByIdPlaying.");
            }
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new base_1.RequiredError("itemIds", "Required parameter itemIds was null or undefined when calling postSessionsByIdPlaying.");
            }
            // verify required parameter 'playCommand' is not null or undefined
            if (playCommand === null || playCommand === undefined) {
                throw new base_1.RequiredError("playCommand", "Required parameter playCommand was null or undefined when calling postSessionsByIdPlaying.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postSessionsByIdPlaying.");
            }
            const localVarPath = `/Sessions/{Id}/Playing`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (itemIds) {
                localVarQueryParameter["ItemIds"] = itemIds;
            }
            if (startPositionTicks !== undefined) {
                localVarQueryParameter["StartPositionTicks"] = startPositionTicks;
            }
            if (playCommand !== undefined) {
                localVarQueryParameter["PlayCommand"] = playCommand;
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a playstate command to a client
         * @param {PlaystateRequest} body PlaystateRequest:
         * @param {string} id Session Id
         * @param {string} command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdPlayingByCommand: async (body, id, command, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postSessionsByIdPlayingByCommand.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postSessionsByIdPlayingByCommand.");
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new base_1.RequiredError("command", "Required parameter command was null or undefined when calling postSessionsByIdPlayingByCommand.");
            }
            const localVarPath = `/Sessions/{Id}/Playing/{Command}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {string} id Session Id
         * @param {string} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdSystemByCommand: async (id, command, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postSessionsByIdSystemByCommand.");
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new base_1.RequiredError("command", "Required parameter command was null or undefined when calling postSessionsByIdSystemByCommand.");
            }
            const localVarPath = `/Sessions/{Id}/System/{Command}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Adds an additional user to a session
         * @param {string} id Session Id
         * @param {string} userId UserId Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdUsersByUserid: async (id, userId, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postSessionsByIdUsersByUserid.");
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError("userId", "Required parameter userId was null or undefined when calling postSessionsByIdUsersByUserid.");
            }
            const localVarPath = `/Sessions/{Id}/Users/{UserId}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Instructs a session to browse to an item or view
         * @param {string} id Session Id
         * @param {string} itemType The type of item to browse to.
         * @param {string} itemId The Id of the item.
         * @param {string} itemName The name of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdViewing: async (id, itemType, itemId, itemName, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postSessionsByIdViewing.");
            }
            // verify required parameter 'itemType' is not null or undefined
            if (itemType === null || itemType === undefined) {
                throw new base_1.RequiredError("itemType", "Required parameter itemType was null or undefined when calling postSessionsByIdViewing.");
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new base_1.RequiredError("itemId", "Required parameter itemId was null or undefined when calling postSessionsByIdViewing.");
            }
            // verify required parameter 'itemName' is not null or undefined
            if (itemName === null || itemName === undefined) {
                throw new base_1.RequiredError("itemName", "Required parameter itemName was null or undefined when calling postSessionsByIdViewing.");
            }
            const localVarPath = `/Sessions/{Id}/Viewing`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (itemType !== undefined) {
                localVarQueryParameter["ItemType"] = itemType;
            }
            if (itemId !== undefined) {
                localVarQueryParameter["ItemId"] = itemId;
            }
            if (itemName !== undefined) {
                localVarQueryParameter["ItemName"] = itemName;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates capabilities for a device
         * @param {string} id Session Id
         * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
         * @param {string} [supportedCommands] A list of supported remote control commands, comma delimited
         * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely.
         * @param {boolean} [supportsSync] Determines whether sync is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsCapabilities: async (id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postSessionsCapabilities.");
            }
            const localVarPath = `/Sessions/Capabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (id !== undefined) {
                localVarQueryParameter["Id"] = id;
            }
            if (playableMediaTypes !== undefined) {
                localVarQueryParameter["PlayableMediaTypes"] = playableMediaTypes;
            }
            if (supportedCommands !== undefined) {
                localVarQueryParameter["SupportedCommands"] = supportedCommands;
            }
            if (supportsMediaControl !== undefined) {
                localVarQueryParameter["SupportsMediaControl"] = supportsMediaControl;
            }
            if (supportsSync !== undefined) {
                localVarQueryParameter["SupportsSync"] = supportsSync;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates capabilities for a device
         * @param {ClientCapabilities} body ClientCapabilities:
         * @param {string} id Session Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsCapabilitiesFull: async (body, id, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postSessionsCapabilitiesFull.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postSessionsCapabilitiesFull.");
            }
            const localVarPath = `/Sessions/Capabilities/Full`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (id !== undefined) {
                localVarQueryParameter["Id"] = id;
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that a session has ended
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsLogout: async (options = {}) => {
            const localVarPath = `/Sessions/Logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SessionsServiceApiAxiosParamCreator = SessionsServiceApiAxiosParamCreator;
/**
 * SessionsServiceApi - functional programming interface
 * @export
 */
const SessionsServiceApiFp = function (configuration) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} key Auth Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthKeysByKey(key, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).deleteAuthKeysByKey(key, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Removes an additional user from a session
         * @param {string} id Session Id
         * @param {string} userId UserId Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSessionsByIdUsersByUserid(id, userId, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).deleteSessionsByIdUsersByUserid(id, userId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthKeys(startIndex, limit, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).getAuthKeys(startIndex, limit, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthProviders(options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).getAuthProviders(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a list of sessions
         * @param {string} [controllableByUserId] Optional. Filter by sessions that a given user is allowed to remote control.
         * @param {string} [deviceId] Optional. Filter by device id.
         * @param {string} [id] Optional. Filter by session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(controllableByUserId, deviceId, id, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).getSessions(controllableByUserId, deviceId, id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a the current play queue from a session
         * @param {string} [id] Optional. Filter by session id.
         * @param {string} [deviceId] Optional. Filter by device id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionsPlayqueue(id, deviceId, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).getSessionsPlayqueue(id, deviceId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} app App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthKeys(app, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).postAuthKeys(app, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {GeneralCommand} body GeneralCommand:
         * @param {string} id Session Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdCommand(body, id, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).postSessionsByIdCommand(body, id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {string} id Session Id
         * @param {string} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdCommandByCommand(id, command, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).postSessionsByIdCommandByCommand(id, command, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a command to a client to display a message to the user
         * @param {string} id Session Id
         * @param {string} text The message text.
         * @param {string} header The message header.
         * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdMessage(id, text, header, timeoutMs, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).postSessionsByIdMessage(id, text, header, timeoutMs, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Instructs a session to play an item
         * @param {PlayRequest} body PlayRequest:
         * @param {Array&lt;number&gt;} itemIds The ids of the items to play, comma delimited
         * @param {string} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
         * @param {string} id Session Id
         * @param {number} [startPositionTicks] The starting position of the first item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdPlaying(body, itemIds, playCommand, id, startPositionTicks, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).postSessionsByIdPlaying(body, itemIds, playCommand, id, startPositionTicks, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a playstate command to a client
         * @param {PlaystateRequest} body PlaystateRequest:
         * @param {string} id Session Id
         * @param {string} command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdPlayingByCommand(body, id, command, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).postSessionsByIdPlayingByCommand(body, id, command, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {string} id Session Id
         * @param {string} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdSystemByCommand(id, command, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).postSessionsByIdSystemByCommand(id, command, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Adds an additional user to a session
         * @param {string} id Session Id
         * @param {string} userId UserId Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdUsersByUserid(id, userId, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).postSessionsByIdUsersByUserid(id, userId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Instructs a session to browse to an item or view
         * @param {string} id Session Id
         * @param {string} itemType The type of item to browse to.
         * @param {string} itemId The Id of the item.
         * @param {string} itemName The name of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdViewing(id, itemType, itemId, itemName, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).postSessionsByIdViewing(id, itemType, itemId, itemName, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates capabilities for a device
         * @param {string} id Session Id
         * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
         * @param {string} [supportedCommands] A list of supported remote control commands, comma delimited
         * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely.
         * @param {boolean} [supportsSync] Determines whether sync is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).postSessionsCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates capabilities for a device
         * @param {ClientCapabilities} body ClientCapabilities:
         * @param {string} id Session Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsCapabilitiesFull(body, id, options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).postSessionsCapabilitiesFull(body, id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that a session has ended
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsLogout(options) {
            const localVarAxiosArgs = await (0, exports.SessionsServiceApiAxiosParamCreator)(configuration).postSessionsLogout(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
exports.SessionsServiceApiFp = SessionsServiceApiFp;
/**
 * SessionsServiceApi - factory interface
 * @export
 */
const SessionsServiceApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} key Auth Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthKeysByKey(key, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .deleteAuthKeysByKey(key, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Removes an additional user from a session
         * @param {string} id Session Id
         * @param {string} userId UserId Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionsByIdUsersByUserid(id, userId, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .deleteSessionsByIdUsersByUserid(id, userId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthKeys(startIndex, limit, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .getAuthKeys(startIndex, limit, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProviders(options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .getAuthProviders(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets a list of sessions
         * @param {string} [controllableByUserId] Optional. Filter by sessions that a given user is allowed to remote control.
         * @param {string} [deviceId] Optional. Filter by device id.
         * @param {string} [id] Optional. Filter by session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(controllableByUserId, deviceId, id, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .getSessions(controllableByUserId, deviceId, id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets a the current play queue from a session
         * @param {string} [id] Optional. Filter by session id.
         * @param {string} [deviceId] Optional. Filter by device id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsPlayqueue(id, deviceId, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .getSessionsPlayqueue(id, deviceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} app App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthKeys(app, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .postAuthKeys(app, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {GeneralCommand} body GeneralCommand:
         * @param {string} id Session Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdCommand(body, id, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .postSessionsByIdCommand(body, id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {string} id Session Id
         * @param {string} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdCommandByCommand(id, command, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .postSessionsByIdCommandByCommand(id, command, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Issues a command to a client to display a message to the user
         * @param {string} id Session Id
         * @param {string} text The message text.
         * @param {string} header The message header.
         * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdMessage(id, text, header, timeoutMs, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .postSessionsByIdMessage(id, text, header, timeoutMs, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Instructs a session to play an item
         * @param {PlayRequest} body PlayRequest:
         * @param {Array&lt;number&gt;} itemIds The ids of the items to play, comma delimited
         * @param {string} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
         * @param {string} id Session Id
         * @param {number} [startPositionTicks] The starting position of the first item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdPlaying(body, itemIds, playCommand, id, startPositionTicks, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .postSessionsByIdPlaying(body, itemIds, playCommand, id, startPositionTicks, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Issues a playstate command to a client
         * @param {PlaystateRequest} body PlaystateRequest:
         * @param {string} id Session Id
         * @param {string} command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdPlayingByCommand(body, id, command, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .postSessionsByIdPlayingByCommand(body, id, command, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {string} id Session Id
         * @param {string} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdSystemByCommand(id, command, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .postSessionsByIdSystemByCommand(id, command, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Adds an additional user to a session
         * @param {string} id Session Id
         * @param {string} userId UserId Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdUsersByUserid(id, userId, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .postSessionsByIdUsersByUserid(id, userId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Instructs a session to browse to an item or view
         * @param {string} id Session Id
         * @param {string} itemType The type of item to browse to.
         * @param {string} itemId The Id of the item.
         * @param {string} itemName The name of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdViewing(id, itemType, itemId, itemName, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .postSessionsByIdViewing(id, itemType, itemId, itemName, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Updates capabilities for a device
         * @param {string} id Session Id
         * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
         * @param {string} [supportedCommands] A list of supported remote control commands, comma delimited
         * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely.
         * @param {boolean} [supportsSync] Determines whether sync is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .postSessionsCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Updates capabilities for a device
         * @param {ClientCapabilities} body ClientCapabilities:
         * @param {string} id Session Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsCapabilitiesFull(body, id, options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .postSessionsCapabilitiesFull(body, id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports that a session has ended
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsLogout(options) {
            return (0, exports.SessionsServiceApiFp)(configuration)
                .postSessionsLogout(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.SessionsServiceApiFactory = SessionsServiceApiFactory;
/**
 * SessionsServiceApi - object-oriented interface
 * @export
 * @class SessionsServiceApi
 * @extends {BaseAPI}
 */
class SessionsServiceApi extends base_1.BaseAPI {
    /**
     * Requires authentication as administrator
     * @param {string} key Auth Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    deleteAuthKeysByKey(key, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .deleteAuthKeysByKey(key, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Removes an additional user from a session
     * @param {string} id Session Id
     * @param {string} userId UserId Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    deleteSessionsByIdUsersByUserid(id, userId, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .deleteSessionsByIdUsersByUserid(id, userId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    getAuthKeys(startIndex, limit, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .getAuthKeys(startIndex, limit, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    getAuthProviders(options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .getAuthProviders(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets a list of sessions
     * @param {string} [controllableByUserId] Optional. Filter by sessions that a given user is allowed to remote control.
     * @param {string} [deviceId] Optional. Filter by device id.
     * @param {string} [id] Optional. Filter by session id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    getSessions(controllableByUserId, deviceId, id, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .getSessions(controllableByUserId, deviceId, id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets a the current play queue from a session
     * @param {string} [id] Optional. Filter by session id.
     * @param {string} [deviceId] Optional. Filter by device id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    getSessionsPlayqueue(id, deviceId, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .getSessionsPlayqueue(id, deviceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} app App
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    postAuthKeys(app, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .postAuthKeys(app, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Issues a system command to a client
     * @param {GeneralCommand} body GeneralCommand:
     * @param {string} id Session Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    postSessionsByIdCommand(body, id, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .postSessionsByIdCommand(body, id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Issues a system command to a client
     * @param {string} id Session Id
     * @param {string} command The command to send.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    postSessionsByIdCommandByCommand(id, command, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .postSessionsByIdCommandByCommand(id, command, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Issues a command to a client to display a message to the user
     * @param {string} id Session Id
     * @param {string} text The message text.
     * @param {string} header The message header.
     * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    postSessionsByIdMessage(id, text, header, timeoutMs, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .postSessionsByIdMessage(id, text, header, timeoutMs, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Instructs a session to play an item
     * @param {PlayRequest} body PlayRequest:
     * @param {Array&lt;number&gt;} itemIds The ids of the items to play, comma delimited
     * @param {string} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
     * @param {string} id Session Id
     * @param {number} [startPositionTicks] The starting position of the first item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    postSessionsByIdPlaying(body, itemIds, playCommand, id, startPositionTicks, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .postSessionsByIdPlaying(body, itemIds, playCommand, id, startPositionTicks, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Issues a playstate command to a client
     * @param {PlaystateRequest} body PlaystateRequest:
     * @param {string} id Session Id
     * @param {string} command
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    postSessionsByIdPlayingByCommand(body, id, command, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .postSessionsByIdPlayingByCommand(body, id, command, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Issues a system command to a client
     * @param {string} id Session Id
     * @param {string} command The command to send.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    postSessionsByIdSystemByCommand(id, command, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .postSessionsByIdSystemByCommand(id, command, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Adds an additional user to a session
     * @param {string} id Session Id
     * @param {string} userId UserId Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    postSessionsByIdUsersByUserid(id, userId, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .postSessionsByIdUsersByUserid(id, userId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Instructs a session to browse to an item or view
     * @param {string} id Session Id
     * @param {string} itemType The type of item to browse to.
     * @param {string} itemId The Id of the item.
     * @param {string} itemName The name of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    postSessionsByIdViewing(id, itemType, itemId, itemName, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .postSessionsByIdViewing(id, itemType, itemId, itemName, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Updates capabilities for a device
     * @param {string} id Session Id
     * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
     * @param {string} [supportedCommands] A list of supported remote control commands, comma delimited
     * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely.
     * @param {boolean} [supportsSync] Determines whether sync is supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    postSessionsCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .postSessionsCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Updates capabilities for a device
     * @param {ClientCapabilities} body ClientCapabilities:
     * @param {string} id Session Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    postSessionsCapabilitiesFull(body, id, options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .postSessionsCapabilitiesFull(body, id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports that a session has ended
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    postSessionsLogout(options) {
        return (0, exports.SessionsServiceApiFp)(this.configuration)
            .postSessionsLogout(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.SessionsServiceApi = SessionsServiceApi;
//# sourceMappingURL=sessions-service-api.js.map