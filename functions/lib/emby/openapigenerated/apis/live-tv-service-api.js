"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveTvServiceApi = exports.LiveTvServiceApiFactory = exports.LiveTvServiceApiFp = exports.LiveTvServiceApiAxiosParamCreator = void 0;
/* tslint:disable */
/* eslint-disable */
/**
 * Emby Server API
 * Explore the Emby Server API
 *
 * OpenAPI spec version: 4.7.0.17
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("../base");
/**
 * LiveTvServiceApi - axios parameter creator
 * @export
 */
const LiveTvServiceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvChannelmappingoptions: async (providerId, options = {}) => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling deleteLivetvChannelmappingoptions.");
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvChannelmappings: async (providerId, options = {}) => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling deleteLivetvChannelmappings.");
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Deletes a listing provider
         * @param {string} [id] Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvListingproviders: async (id, options = {}) => {
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (id !== undefined) {
                localVarQueryParameter["Id"] = id;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Deletes a live tv recording
         * @param {string} id Recording Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvRecordingsById: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling deleteLivetvRecordingsById.");
            }
            const localVarPath = `/LiveTv/Recordings/{Id}`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Cancels a live tv series timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvSeriestimersById: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling deleteLivetvSeriestimersById.");
            }
            const localVarPath = `/LiveTv/SeriesTimers/{Id}`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Cancels a live tv timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvTimersById: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling deleteLivetvTimersById.");
            }
            const localVarPath = `/LiveTv/Timers/{Id}`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Deletes a tuner host
         * @param {string} [id] Tuner host id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvTunerhosts: async (id, options = {}) => {
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (id !== undefined) {
                localVarQueryParameter["Id"] = id;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannelmappingoptions: async (providerId, options = {}) => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling getLivetvChannelmappingoptions.");
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannelmappings: async (providerId, options = {}) => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling getLivetvChannelmappings.");
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv channels.
         * @param {string} [type] Optional filter by channel type.
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
         * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannels: async (type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, options = {}) => {
            const localVarPath = `/LiveTv/Channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (type !== undefined) {
                localVarQueryParameter["Type"] = type;
            }
            if (userId !== undefined) {
                localVarQueryParameter["UserId"] = userId;
            }
            if (startIndex !== undefined) {
                localVarQueryParameter["StartIndex"] = startIndex;
            }
            if (isMovie !== undefined) {
                localVarQueryParameter["IsMovie"] = isMovie;
            }
            if (isSeries !== undefined) {
                localVarQueryParameter["IsSeries"] = isSeries;
            }
            if (isNews !== undefined) {
                localVarQueryParameter["IsNews"] = isNews;
            }
            if (isKids !== undefined) {
                localVarQueryParameter["IsKids"] = isKids;
            }
            if (isSports !== undefined) {
                localVarQueryParameter["IsSports"] = isSports;
            }
            if (limit !== undefined) {
                localVarQueryParameter["Limit"] = limit;
            }
            if (isFavorite !== undefined) {
                localVarQueryParameter["IsFavorite"] = isFavorite;
            }
            if (isLiked !== undefined) {
                localVarQueryParameter["IsLiked"] = isLiked;
            }
            if (isDisliked !== undefined) {
                localVarQueryParameter["IsDisliked"] = isDisliked;
            }
            if (enableFavoriteSorting !== undefined) {
                localVarQueryParameter["EnableFavoriteSorting"] = enableFavoriteSorting;
            }
            if (enableImages !== undefined) {
                localVarQueryParameter["EnableImages"] = enableImages;
            }
            if (imageTypeLimit !== undefined) {
                localVarQueryParameter["ImageTypeLimit"] = imageTypeLimit;
            }
            if (enableImageTypes !== undefined) {
                localVarQueryParameter["EnableImageTypes"] = enableImageTypes;
            }
            if (fields !== undefined) {
                localVarQueryParameter["Fields"] = fields;
            }
            if (addCurrentProgram !== undefined) {
                localVarQueryParameter["AddCurrentProgram"] = addCurrentProgram;
            }
            if (enableUserData !== undefined) {
                localVarQueryParameter["EnableUserData"] = enableUserData;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv channel
         * @param {string} id Channel Id
         * @param {string} [userId] Optional attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannelsById: async (id, userId, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling getLivetvChannelsById.");
            }
            const localVarPath = `/LiveTv/Channels/{Id}`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (userId !== undefined) {
                localVarQueryParameter["UserId"] = userId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @summary Gets live tv channel tags
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChanneltags: async (artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options = {}) => {
            const localVarPath = `/LiveTv/ChannelTags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (artistType !== undefined) {
                localVarQueryParameter["ArtistType"] = artistType;
            }
            if (maxOfficialRating !== undefined) {
                localVarQueryParameter["MaxOfficialRating"] = maxOfficialRating;
            }
            if (hasThemeSong !== undefined) {
                localVarQueryParameter["HasThemeSong"] = hasThemeSong;
            }
            if (hasThemeVideo !== undefined) {
                localVarQueryParameter["HasThemeVideo"] = hasThemeVideo;
            }
            if (hasSubtitles !== undefined) {
                localVarQueryParameter["HasSubtitles"] = hasSubtitles;
            }
            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter["HasSpecialFeature"] = hasSpecialFeature;
            }
            if (hasTrailer !== undefined) {
                localVarQueryParameter["HasTrailer"] = hasTrailer;
            }
            if (adjacentTo !== undefined) {
                localVarQueryParameter["AdjacentTo"] = adjacentTo;
            }
            if (minIndexNumber !== undefined) {
                localVarQueryParameter["MinIndexNumber"] = minIndexNumber;
            }
            if (minPlayers !== undefined) {
                localVarQueryParameter["MinPlayers"] = minPlayers;
            }
            if (maxPlayers !== undefined) {
                localVarQueryParameter["MaxPlayers"] = maxPlayers;
            }
            if (parentIndexNumber !== undefined) {
                localVarQueryParameter["ParentIndexNumber"] = parentIndexNumber;
            }
            if (hasParentalRating !== undefined) {
                localVarQueryParameter["HasParentalRating"] = hasParentalRating;
            }
            if (isHD !== undefined) {
                localVarQueryParameter["IsHD"] = isHD;
            }
            if (locationTypes !== undefined) {
                localVarQueryParameter["LocationTypes"] = locationTypes;
            }
            if (excludeLocationTypes !== undefined) {
                localVarQueryParameter["ExcludeLocationTypes"] = excludeLocationTypes;
            }
            if (isMissing !== undefined) {
                localVarQueryParameter["IsMissing"] = isMissing;
            }
            if (isUnaired !== undefined) {
                localVarQueryParameter["IsUnaired"] = isUnaired;
            }
            if (minCommunityRating !== undefined) {
                localVarQueryParameter["MinCommunityRating"] = minCommunityRating;
            }
            if (minCriticRating !== undefined) {
                localVarQueryParameter["MinCriticRating"] = minCriticRating;
            }
            if (airedDuringSeason !== undefined) {
                localVarQueryParameter["AiredDuringSeason"] = airedDuringSeason;
            }
            if (minPremiereDate !== undefined) {
                localVarQueryParameter["MinPremiereDate"] = minPremiereDate;
            }
            if (minDateLastSaved !== undefined) {
                localVarQueryParameter["MinDateLastSaved"] = minDateLastSaved;
            }
            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter["MinDateLastSavedForUser"] =
                    minDateLastSavedForUser;
            }
            if (maxPremiereDate !== undefined) {
                localVarQueryParameter["MaxPremiereDate"] = maxPremiereDate;
            }
            if (hasOverview !== undefined) {
                localVarQueryParameter["HasOverview"] = hasOverview;
            }
            if (hasImdbId !== undefined) {
                localVarQueryParameter["HasImdbId"] = hasImdbId;
            }
            if (hasTmdbId !== undefined) {
                localVarQueryParameter["HasTmdbId"] = hasTmdbId;
            }
            if (hasTvdbId !== undefined) {
                localVarQueryParameter["HasTvdbId"] = hasTvdbId;
            }
            if (excludeItemIds !== undefined) {
                localVarQueryParameter["ExcludeItemIds"] = excludeItemIds;
            }
            if (startIndex !== undefined) {
                localVarQueryParameter["StartIndex"] = startIndex;
            }
            if (limit !== undefined) {
                localVarQueryParameter["Limit"] = limit;
            }
            if (recursive !== undefined) {
                localVarQueryParameter["Recursive"] = recursive;
            }
            if (searchTerm !== undefined) {
                localVarQueryParameter["SearchTerm"] = searchTerm;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter["SortOrder"] = sortOrder;
            }
            if (parentId !== undefined) {
                localVarQueryParameter["ParentId"] = parentId;
            }
            if (fields !== undefined) {
                localVarQueryParameter["Fields"] = fields;
            }
            if (excludeItemTypes !== undefined) {
                localVarQueryParameter["ExcludeItemTypes"] = excludeItemTypes;
            }
            if (includeItemTypes !== undefined) {
                localVarQueryParameter["IncludeItemTypes"] = includeItemTypes;
            }
            if (anyProviderIdEquals !== undefined) {
                localVarQueryParameter["AnyProviderIdEquals"] = anyProviderIdEquals;
            }
            if (filters !== undefined) {
                localVarQueryParameter["Filters"] = filters;
            }
            if (isFavorite !== undefined) {
                localVarQueryParameter["IsFavorite"] = isFavorite;
            }
            if (isMovie !== undefined) {
                localVarQueryParameter["IsMovie"] = isMovie;
            }
            if (isSeries !== undefined) {
                localVarQueryParameter["IsSeries"] = isSeries;
            }
            if (isNews !== undefined) {
                localVarQueryParameter["IsNews"] = isNews;
            }
            if (isKids !== undefined) {
                localVarQueryParameter["IsKids"] = isKids;
            }
            if (isSports !== undefined) {
                localVarQueryParameter["IsSports"] = isSports;
            }
            if (mediaTypes !== undefined) {
                localVarQueryParameter["MediaTypes"] = mediaTypes;
            }
            if (imageTypes !== undefined) {
                localVarQueryParameter["ImageTypes"] = imageTypes;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter["SortBy"] = sortBy;
            }
            if (isPlayed !== undefined) {
                localVarQueryParameter["IsPlayed"] = isPlayed;
            }
            if (genres !== undefined) {
                localVarQueryParameter["Genres"] = genres;
            }
            if (officialRatings !== undefined) {
                localVarQueryParameter["OfficialRatings"] = officialRatings;
            }
            if (tags !== undefined) {
                localVarQueryParameter["Tags"] = tags;
            }
            if (years !== undefined) {
                localVarQueryParameter["Years"] = years;
            }
            if (enableImages !== undefined) {
                localVarQueryParameter["EnableImages"] = enableImages;
            }
            if (enableUserData !== undefined) {
                localVarQueryParameter["EnableUserData"] = enableUserData;
            }
            if (imageTypeLimit !== undefined) {
                localVarQueryParameter["ImageTypeLimit"] = imageTypeLimit;
            }
            if (enableImageTypes !== undefined) {
                localVarQueryParameter["EnableImageTypes"] = enableImageTypes;
            }
            if (person !== undefined) {
                localVarQueryParameter["Person"] = person;
            }
            if (personIds !== undefined) {
                localVarQueryParameter["PersonIds"] = personIds;
            }
            if (personTypes !== undefined) {
                localVarQueryParameter["PersonTypes"] = personTypes;
            }
            if (studios !== undefined) {
                localVarQueryParameter["Studios"] = studios;
            }
            if (studioIds !== undefined) {
                localVarQueryParameter["StudioIds"] = studioIds;
            }
            if (artists !== undefined) {
                localVarQueryParameter["Artists"] = artists;
            }
            if (artistIds !== undefined) {
                localVarQueryParameter["ArtistIds"] = artistIds;
            }
            if (albums !== undefined) {
                localVarQueryParameter["Albums"] = albums;
            }
            if (ids !== undefined) {
                localVarQueryParameter["Ids"] = ids;
            }
            if (videoTypes !== undefined) {
                localVarQueryParameter["VideoTypes"] = videoTypes;
            }
            if (containers !== undefined) {
                localVarQueryParameter["Containers"] = containers;
            }
            if (audioCodecs !== undefined) {
                localVarQueryParameter["AudioCodecs"] = audioCodecs;
            }
            if (videoCodecs !== undefined) {
                localVarQueryParameter["VideoCodecs"] = videoCodecs;
            }
            if (subtitleCodecs !== undefined) {
                localVarQueryParameter["SubtitleCodecs"] = subtitleCodecs;
            }
            if (path !== undefined) {
                localVarQueryParameter["Path"] = path;
            }
            if (userId !== undefined) {
                localVarQueryParameter["UserId"] = userId;
            }
            if (minOfficialRating !== undefined) {
                localVarQueryParameter["MinOfficialRating"] = minOfficialRating;
            }
            if (isLocked !== undefined) {
                localVarQueryParameter["IsLocked"] = isLocked;
            }
            if (isPlaceHolder !== undefined) {
                localVarQueryParameter["IsPlaceHolder"] = isPlaceHolder;
            }
            if (hasOfficialRating !== undefined) {
                localVarQueryParameter["HasOfficialRating"] = hasOfficialRating;
            }
            if (groupItemsIntoCollections !== undefined) {
                localVarQueryParameter["GroupItemsIntoCollections"] =
                    groupItemsIntoCollections;
            }
            if (is3D !== undefined) {
                localVarQueryParameter["Is3D"] = is3D;
            }
            if (seriesStatus !== undefined) {
                localVarQueryParameter["SeriesStatus"] = seriesStatus;
            }
            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter["NameStartsWithOrGreater"] =
                    nameStartsWithOrGreater;
            }
            if (nameStartsWith !== undefined) {
                localVarQueryParameter["NameStartsWith"] = nameStartsWith;
            }
            if (nameLessThan !== undefined) {
                localVarQueryParameter["NameLessThan"] = nameLessThan;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @summary Gets live tv channel tag prefixes
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChanneltagsPrefixes: async (artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options = {}) => {
            const localVarPath = `/LiveTv/ChannelTags/Prefixes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (artistType !== undefined) {
                localVarQueryParameter["ArtistType"] = artistType;
            }
            if (maxOfficialRating !== undefined) {
                localVarQueryParameter["MaxOfficialRating"] = maxOfficialRating;
            }
            if (hasThemeSong !== undefined) {
                localVarQueryParameter["HasThemeSong"] = hasThemeSong;
            }
            if (hasThemeVideo !== undefined) {
                localVarQueryParameter["HasThemeVideo"] = hasThemeVideo;
            }
            if (hasSubtitles !== undefined) {
                localVarQueryParameter["HasSubtitles"] = hasSubtitles;
            }
            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter["HasSpecialFeature"] = hasSpecialFeature;
            }
            if (hasTrailer !== undefined) {
                localVarQueryParameter["HasTrailer"] = hasTrailer;
            }
            if (adjacentTo !== undefined) {
                localVarQueryParameter["AdjacentTo"] = adjacentTo;
            }
            if (minIndexNumber !== undefined) {
                localVarQueryParameter["MinIndexNumber"] = minIndexNumber;
            }
            if (minPlayers !== undefined) {
                localVarQueryParameter["MinPlayers"] = minPlayers;
            }
            if (maxPlayers !== undefined) {
                localVarQueryParameter["MaxPlayers"] = maxPlayers;
            }
            if (parentIndexNumber !== undefined) {
                localVarQueryParameter["ParentIndexNumber"] = parentIndexNumber;
            }
            if (hasParentalRating !== undefined) {
                localVarQueryParameter["HasParentalRating"] = hasParentalRating;
            }
            if (isHD !== undefined) {
                localVarQueryParameter["IsHD"] = isHD;
            }
            if (locationTypes !== undefined) {
                localVarQueryParameter["LocationTypes"] = locationTypes;
            }
            if (excludeLocationTypes !== undefined) {
                localVarQueryParameter["ExcludeLocationTypes"] = excludeLocationTypes;
            }
            if (isMissing !== undefined) {
                localVarQueryParameter["IsMissing"] = isMissing;
            }
            if (isUnaired !== undefined) {
                localVarQueryParameter["IsUnaired"] = isUnaired;
            }
            if (minCommunityRating !== undefined) {
                localVarQueryParameter["MinCommunityRating"] = minCommunityRating;
            }
            if (minCriticRating !== undefined) {
                localVarQueryParameter["MinCriticRating"] = minCriticRating;
            }
            if (airedDuringSeason !== undefined) {
                localVarQueryParameter["AiredDuringSeason"] = airedDuringSeason;
            }
            if (minPremiereDate !== undefined) {
                localVarQueryParameter["MinPremiereDate"] = minPremiereDate;
            }
            if (minDateLastSaved !== undefined) {
                localVarQueryParameter["MinDateLastSaved"] = minDateLastSaved;
            }
            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter["MinDateLastSavedForUser"] =
                    minDateLastSavedForUser;
            }
            if (maxPremiereDate !== undefined) {
                localVarQueryParameter["MaxPremiereDate"] = maxPremiereDate;
            }
            if (hasOverview !== undefined) {
                localVarQueryParameter["HasOverview"] = hasOverview;
            }
            if (hasImdbId !== undefined) {
                localVarQueryParameter["HasImdbId"] = hasImdbId;
            }
            if (hasTmdbId !== undefined) {
                localVarQueryParameter["HasTmdbId"] = hasTmdbId;
            }
            if (hasTvdbId !== undefined) {
                localVarQueryParameter["HasTvdbId"] = hasTvdbId;
            }
            if (excludeItemIds !== undefined) {
                localVarQueryParameter["ExcludeItemIds"] = excludeItemIds;
            }
            if (startIndex !== undefined) {
                localVarQueryParameter["StartIndex"] = startIndex;
            }
            if (limit !== undefined) {
                localVarQueryParameter["Limit"] = limit;
            }
            if (recursive !== undefined) {
                localVarQueryParameter["Recursive"] = recursive;
            }
            if (searchTerm !== undefined) {
                localVarQueryParameter["SearchTerm"] = searchTerm;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter["SortOrder"] = sortOrder;
            }
            if (parentId !== undefined) {
                localVarQueryParameter["ParentId"] = parentId;
            }
            if (fields !== undefined) {
                localVarQueryParameter["Fields"] = fields;
            }
            if (excludeItemTypes !== undefined) {
                localVarQueryParameter["ExcludeItemTypes"] = excludeItemTypes;
            }
            if (includeItemTypes !== undefined) {
                localVarQueryParameter["IncludeItemTypes"] = includeItemTypes;
            }
            if (anyProviderIdEquals !== undefined) {
                localVarQueryParameter["AnyProviderIdEquals"] = anyProviderIdEquals;
            }
            if (filters !== undefined) {
                localVarQueryParameter["Filters"] = filters;
            }
            if (isFavorite !== undefined) {
                localVarQueryParameter["IsFavorite"] = isFavorite;
            }
            if (isMovie !== undefined) {
                localVarQueryParameter["IsMovie"] = isMovie;
            }
            if (isSeries !== undefined) {
                localVarQueryParameter["IsSeries"] = isSeries;
            }
            if (isNews !== undefined) {
                localVarQueryParameter["IsNews"] = isNews;
            }
            if (isKids !== undefined) {
                localVarQueryParameter["IsKids"] = isKids;
            }
            if (isSports !== undefined) {
                localVarQueryParameter["IsSports"] = isSports;
            }
            if (mediaTypes !== undefined) {
                localVarQueryParameter["MediaTypes"] = mediaTypes;
            }
            if (imageTypes !== undefined) {
                localVarQueryParameter["ImageTypes"] = imageTypes;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter["SortBy"] = sortBy;
            }
            if (isPlayed !== undefined) {
                localVarQueryParameter["IsPlayed"] = isPlayed;
            }
            if (genres !== undefined) {
                localVarQueryParameter["Genres"] = genres;
            }
            if (officialRatings !== undefined) {
                localVarQueryParameter["OfficialRatings"] = officialRatings;
            }
            if (tags !== undefined) {
                localVarQueryParameter["Tags"] = tags;
            }
            if (years !== undefined) {
                localVarQueryParameter["Years"] = years;
            }
            if (enableImages !== undefined) {
                localVarQueryParameter["EnableImages"] = enableImages;
            }
            if (enableUserData !== undefined) {
                localVarQueryParameter["EnableUserData"] = enableUserData;
            }
            if (imageTypeLimit !== undefined) {
                localVarQueryParameter["ImageTypeLimit"] = imageTypeLimit;
            }
            if (enableImageTypes !== undefined) {
                localVarQueryParameter["EnableImageTypes"] = enableImageTypes;
            }
            if (person !== undefined) {
                localVarQueryParameter["Person"] = person;
            }
            if (personIds !== undefined) {
                localVarQueryParameter["PersonIds"] = personIds;
            }
            if (personTypes !== undefined) {
                localVarQueryParameter["PersonTypes"] = personTypes;
            }
            if (studios !== undefined) {
                localVarQueryParameter["Studios"] = studios;
            }
            if (studioIds !== undefined) {
                localVarQueryParameter["StudioIds"] = studioIds;
            }
            if (artists !== undefined) {
                localVarQueryParameter["Artists"] = artists;
            }
            if (artistIds !== undefined) {
                localVarQueryParameter["ArtistIds"] = artistIds;
            }
            if (albums !== undefined) {
                localVarQueryParameter["Albums"] = albums;
            }
            if (ids !== undefined) {
                localVarQueryParameter["Ids"] = ids;
            }
            if (videoTypes !== undefined) {
                localVarQueryParameter["VideoTypes"] = videoTypes;
            }
            if (containers !== undefined) {
                localVarQueryParameter["Containers"] = containers;
            }
            if (audioCodecs !== undefined) {
                localVarQueryParameter["AudioCodecs"] = audioCodecs;
            }
            if (videoCodecs !== undefined) {
                localVarQueryParameter["VideoCodecs"] = videoCodecs;
            }
            if (subtitleCodecs !== undefined) {
                localVarQueryParameter["SubtitleCodecs"] = subtitleCodecs;
            }
            if (path !== undefined) {
                localVarQueryParameter["Path"] = path;
            }
            if (userId !== undefined) {
                localVarQueryParameter["UserId"] = userId;
            }
            if (minOfficialRating !== undefined) {
                localVarQueryParameter["MinOfficialRating"] = minOfficialRating;
            }
            if (isLocked !== undefined) {
                localVarQueryParameter["IsLocked"] = isLocked;
            }
            if (isPlaceHolder !== undefined) {
                localVarQueryParameter["IsPlaceHolder"] = isPlaceHolder;
            }
            if (hasOfficialRating !== undefined) {
                localVarQueryParameter["HasOfficialRating"] = hasOfficialRating;
            }
            if (groupItemsIntoCollections !== undefined) {
                localVarQueryParameter["GroupItemsIntoCollections"] =
                    groupItemsIntoCollections;
            }
            if (is3D !== undefined) {
                localVarQueryParameter["Is3D"] = is3D;
            }
            if (seriesStatus !== undefined) {
                localVarQueryParameter["SeriesStatus"] = seriesStatus;
            }
            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter["NameStartsWithOrGreater"] =
                    nameStartsWithOrGreater;
            }
            if (nameStartsWith !== undefined) {
                localVarQueryParameter["NameStartsWith"] = nameStartsWith;
            }
            if (nameLessThan !== undefined) {
                localVarQueryParameter["NameLessThan"] = nameLessThan;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets the epg.
         * @param {string} [type] Optional filter by channel type.
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
         * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvEPG: async (type, userId, genreIds, minStartDate, maxStartDate, minEndDate, maxEndDate, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, channelIds, options = {}) => {
            const localVarPath = `/LiveTv/EPG`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (type !== undefined) {
                localVarQueryParameter["Type"] = type;
            }
            if (userId !== undefined) {
                localVarQueryParameter["UserId"] = userId;
            }
            if (genreIds !== undefined) {
                localVarQueryParameter["GenreIds"] = genreIds;
            }
            if (minStartDate !== undefined) {
                localVarQueryParameter["MinStartDate"] = minStartDate;
            }
            if (maxStartDate !== undefined) {
                localVarQueryParameter["MaxStartDate"] = maxStartDate;
            }
            if (minEndDate !== undefined) {
                localVarQueryParameter["MinEndDate"] = minEndDate;
            }
            if (maxEndDate !== undefined) {
                localVarQueryParameter["MaxEndDate"] = maxEndDate;
            }
            if (startIndex !== undefined) {
                localVarQueryParameter["StartIndex"] = startIndex;
            }
            if (isMovie !== undefined) {
                localVarQueryParameter["IsMovie"] = isMovie;
            }
            if (isSeries !== undefined) {
                localVarQueryParameter["IsSeries"] = isSeries;
            }
            if (isNews !== undefined) {
                localVarQueryParameter["IsNews"] = isNews;
            }
            if (isKids !== undefined) {
                localVarQueryParameter["IsKids"] = isKids;
            }
            if (isSports !== undefined) {
                localVarQueryParameter["IsSports"] = isSports;
            }
            if (limit !== undefined) {
                localVarQueryParameter["Limit"] = limit;
            }
            if (isFavorite !== undefined) {
                localVarQueryParameter["IsFavorite"] = isFavorite;
            }
            if (isLiked !== undefined) {
                localVarQueryParameter["IsLiked"] = isLiked;
            }
            if (isDisliked !== undefined) {
                localVarQueryParameter["IsDisliked"] = isDisliked;
            }
            if (enableFavoriteSorting !== undefined) {
                localVarQueryParameter["EnableFavoriteSorting"] = enableFavoriteSorting;
            }
            if (enableImages !== undefined) {
                localVarQueryParameter["EnableImages"] = enableImages;
            }
            if (imageTypeLimit !== undefined) {
                localVarQueryParameter["ImageTypeLimit"] = imageTypeLimit;
            }
            if (enableImageTypes !== undefined) {
                localVarQueryParameter["EnableImageTypes"] = enableImageTypes;
            }
            if (fields !== undefined) {
                localVarQueryParameter["Fields"] = fields;
            }
            if (addCurrentProgram !== undefined) {
                localVarQueryParameter["AddCurrentProgram"] = addCurrentProgram;
            }
            if (enableUserData !== undefined) {
                localVarQueryParameter["EnableUserData"] = enableUserData;
            }
            if (channelIds !== undefined) {
                localVarQueryParameter["ChannelIds"] = channelIds;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets the top level live tv folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvFolder: async (options = {}) => {
            const localVarPath = `/LiveTv/Folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets guide info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvGuideinfo: async (options = {}) => {
            const localVarPath = `/LiveTv/GuideInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvInfo: async (options = {}) => {
            const localVarPath = `/LiveTv/Info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets current listing providers
         * @param {string} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingproviders: async (channelId, options = {}) => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError("channelId", "Required parameter channelId was null or undefined when calling getLivetvListingproviders.");
            }
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (channelId !== undefined) {
                localVarQueryParameter["ChannelId"] = channelId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets listing provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersAvailable: async (options = {}) => {
            const localVarPath = `/LiveTv/ListingProviders/Available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersDefault: async (options = {}) => {
            const localVarPath = `/LiveTv/ListingProviders/Default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets available lineups
         * @param {string} [id] Provider id
         * @param {string} [type] Provider Type
         * @param {string} [location] Location
         * @param {string} [country] Country
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersLineups: async (id, type, location, country, options = {}) => {
            const localVarPath = `/LiveTv/ListingProviders/Lineups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (id !== undefined) {
                localVarQueryParameter["Id"] = id;
            }
            if (type !== undefined) {
                localVarQueryParameter["Type"] = type;
            }
            if (location !== undefined) {
                localVarQueryParameter["Location"] = location;
            }
            if (country !== undefined) {
                localVarQueryParameter["Country"] = country;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets available lineups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersSchedulesdirectCountries: async (options = {}) => {
            const localVarPath = `/LiveTv/ListingProviders/SchedulesDirect/Countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @summary Gets a live tv channel
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvLiverecordingsByIdStream: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling getLivetvLiverecordingsByIdStream.");
            }
            const localVarPath = `/LiveTv/LiveRecordings/{Id}/stream`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @summary Gets a live tv channel
         * @param {string} id
         * @param {string} container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvLivestreamfilesByIdByContainer: async (id, container, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling getLivetvLivestreamfilesByIdByContainer.");
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new base_1.RequiredError("container", "Required parameter container was null or undefined when calling getLivetvLivestreamfilesByIdByContainer.");
            }
            const localVarPath = `/LiveTv/LiveStreamFiles/{Id}/stream.{Container}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets the channel management list
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvManageChannels: async (startIndex, limit, sortBy, sortOrder, options = {}) => {
            const localVarPath = `/LiveTv/Manage/Channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (startIndex !== undefined) {
                localVarQueryParameter["StartIndex"] = startIndex;
            }
            if (limit !== undefined) {
                localVarQueryParameter["Limit"] = limit;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter["SortBy"] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter["SortOrder"] = sortOrder;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional filter by user id.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvPrograms: async (channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields, options = {}) => {
            const localVarPath = `/LiveTv/Programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (channelIds !== undefined) {
                localVarQueryParameter["ChannelIds"] = channelIds;
            }
            if (userId !== undefined) {
                localVarQueryParameter["UserId"] = userId;
            }
            if (hasAired !== undefined) {
                localVarQueryParameter["HasAired"] = hasAired;
            }
            if (minStartDate !== undefined) {
                localVarQueryParameter["MinStartDate"] = minStartDate;
            }
            if (maxStartDate !== undefined) {
                localVarQueryParameter["MaxStartDate"] = maxStartDate;
            }
            if (minEndDate !== undefined) {
                localVarQueryParameter["MinEndDate"] = minEndDate;
            }
            if (maxEndDate !== undefined) {
                localVarQueryParameter["MaxEndDate"] = maxEndDate;
            }
            if (isMovie !== undefined) {
                localVarQueryParameter["IsMovie"] = isMovie;
            }
            if (isSeries !== undefined) {
                localVarQueryParameter["IsSeries"] = isSeries;
            }
            if (isNews !== undefined) {
                localVarQueryParameter["IsNews"] = isNews;
            }
            if (isKids !== undefined) {
                localVarQueryParameter["IsKids"] = isKids;
            }
            if (isSports !== undefined) {
                localVarQueryParameter["IsSports"] = isSports;
            }
            if (startIndex !== undefined) {
                localVarQueryParameter["StartIndex"] = startIndex;
            }
            if (limit !== undefined) {
                localVarQueryParameter["Limit"] = limit;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter["SortBy"] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter["SortOrder"] = sortOrder;
            }
            if (genreIds !== undefined) {
                localVarQueryParameter["GenreIds"] = genreIds;
            }
            if (enableImages !== undefined) {
                localVarQueryParameter["EnableImages"] = enableImages;
            }
            if (imageTypeLimit !== undefined) {
                localVarQueryParameter["ImageTypeLimit"] = imageTypeLimit;
            }
            if (enableImageTypes !== undefined) {
                localVarQueryParameter["EnableImageTypes"] = enableImageTypes;
            }
            if (enableUserData !== undefined) {
                localVarQueryParameter["EnableUserData"] = enableUserData;
            }
            if (fields !== undefined) {
                localVarQueryParameter["Fields"] = fields;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {string} [userId] Optional filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvProgramsRecommended: async (userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, options = {}) => {
            const localVarPath = `/LiveTv/Programs/Recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (userId !== undefined) {
                localVarQueryParameter["UserId"] = userId;
            }
            if (limit !== undefined) {
                localVarQueryParameter["Limit"] = limit;
            }
            if (isAiring !== undefined) {
                localVarQueryParameter["IsAiring"] = isAiring;
            }
            if (hasAired !== undefined) {
                localVarQueryParameter["HasAired"] = hasAired;
            }
            if (isSeries !== undefined) {
                localVarQueryParameter["IsSeries"] = isSeries;
            }
            if (isMovie !== undefined) {
                localVarQueryParameter["IsMovie"] = isMovie;
            }
            if (isNews !== undefined) {
                localVarQueryParameter["IsNews"] = isNews;
            }
            if (isKids !== undefined) {
                localVarQueryParameter["IsKids"] = isKids;
            }
            if (isSports !== undefined) {
                localVarQueryParameter["IsSports"] = isSports;
            }
            if (enableImages !== undefined) {
                localVarQueryParameter["EnableImages"] = enableImages;
            }
            if (imageTypeLimit !== undefined) {
                localVarQueryParameter["ImageTypeLimit"] = imageTypeLimit;
            }
            if (enableImageTypes !== undefined) {
                localVarQueryParameter["EnableImageTypes"] = enableImageTypes;
            }
            if (genreIds !== undefined) {
                localVarQueryParameter["GenreIds"] = genreIds;
            }
            if (fields !== undefined) {
                localVarQueryParameter["Fields"] = fields;
            }
            if (enableUserData !== undefined) {
                localVarQueryParameter["EnableUserData"] = enableUserData;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recordings
         * @param {string} [channelId] Optional filter by channel id.
         * @param {string} [status] Optional filter by recording status.
         * @param {boolean} [isInProgress] Optional filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional filter by recordings belonging to a series timer
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordings: async (channelId, status, isInProgress, seriesTimerId, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options = {}) => {
            const localVarPath = `/LiveTv/Recordings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (channelId !== undefined) {
                localVarQueryParameter["ChannelId"] = channelId;
            }
            if (status !== undefined) {
                localVarQueryParameter["Status"] = status;
            }
            if (isInProgress !== undefined) {
                localVarQueryParameter["IsInProgress"] = isInProgress;
            }
            if (seriesTimerId !== undefined) {
                localVarQueryParameter["SeriesTimerId"] = seriesTimerId;
            }
            if (artistType !== undefined) {
                localVarQueryParameter["ArtistType"] = artistType;
            }
            if (maxOfficialRating !== undefined) {
                localVarQueryParameter["MaxOfficialRating"] = maxOfficialRating;
            }
            if (hasThemeSong !== undefined) {
                localVarQueryParameter["HasThemeSong"] = hasThemeSong;
            }
            if (hasThemeVideo !== undefined) {
                localVarQueryParameter["HasThemeVideo"] = hasThemeVideo;
            }
            if (hasSubtitles !== undefined) {
                localVarQueryParameter["HasSubtitles"] = hasSubtitles;
            }
            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter["HasSpecialFeature"] = hasSpecialFeature;
            }
            if (hasTrailer !== undefined) {
                localVarQueryParameter["HasTrailer"] = hasTrailer;
            }
            if (adjacentTo !== undefined) {
                localVarQueryParameter["AdjacentTo"] = adjacentTo;
            }
            if (minIndexNumber !== undefined) {
                localVarQueryParameter["MinIndexNumber"] = minIndexNumber;
            }
            if (minPlayers !== undefined) {
                localVarQueryParameter["MinPlayers"] = minPlayers;
            }
            if (maxPlayers !== undefined) {
                localVarQueryParameter["MaxPlayers"] = maxPlayers;
            }
            if (parentIndexNumber !== undefined) {
                localVarQueryParameter["ParentIndexNumber"] = parentIndexNumber;
            }
            if (hasParentalRating !== undefined) {
                localVarQueryParameter["HasParentalRating"] = hasParentalRating;
            }
            if (isHD !== undefined) {
                localVarQueryParameter["IsHD"] = isHD;
            }
            if (locationTypes !== undefined) {
                localVarQueryParameter["LocationTypes"] = locationTypes;
            }
            if (excludeLocationTypes !== undefined) {
                localVarQueryParameter["ExcludeLocationTypes"] = excludeLocationTypes;
            }
            if (isMissing !== undefined) {
                localVarQueryParameter["IsMissing"] = isMissing;
            }
            if (isUnaired !== undefined) {
                localVarQueryParameter["IsUnaired"] = isUnaired;
            }
            if (minCommunityRating !== undefined) {
                localVarQueryParameter["MinCommunityRating"] = minCommunityRating;
            }
            if (minCriticRating !== undefined) {
                localVarQueryParameter["MinCriticRating"] = minCriticRating;
            }
            if (airedDuringSeason !== undefined) {
                localVarQueryParameter["AiredDuringSeason"] = airedDuringSeason;
            }
            if (minPremiereDate !== undefined) {
                localVarQueryParameter["MinPremiereDate"] = minPremiereDate;
            }
            if (minDateLastSaved !== undefined) {
                localVarQueryParameter["MinDateLastSaved"] = minDateLastSaved;
            }
            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter["MinDateLastSavedForUser"] =
                    minDateLastSavedForUser;
            }
            if (maxPremiereDate !== undefined) {
                localVarQueryParameter["MaxPremiereDate"] = maxPremiereDate;
            }
            if (hasOverview !== undefined) {
                localVarQueryParameter["HasOverview"] = hasOverview;
            }
            if (hasImdbId !== undefined) {
                localVarQueryParameter["HasImdbId"] = hasImdbId;
            }
            if (hasTmdbId !== undefined) {
                localVarQueryParameter["HasTmdbId"] = hasTmdbId;
            }
            if (hasTvdbId !== undefined) {
                localVarQueryParameter["HasTvdbId"] = hasTvdbId;
            }
            if (excludeItemIds !== undefined) {
                localVarQueryParameter["ExcludeItemIds"] = excludeItemIds;
            }
            if (startIndex !== undefined) {
                localVarQueryParameter["StartIndex"] = startIndex;
            }
            if (limit !== undefined) {
                localVarQueryParameter["Limit"] = limit;
            }
            if (recursive !== undefined) {
                localVarQueryParameter["Recursive"] = recursive;
            }
            if (searchTerm !== undefined) {
                localVarQueryParameter["SearchTerm"] = searchTerm;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter["SortOrder"] = sortOrder;
            }
            if (parentId !== undefined) {
                localVarQueryParameter["ParentId"] = parentId;
            }
            if (fields !== undefined) {
                localVarQueryParameter["Fields"] = fields;
            }
            if (excludeItemTypes !== undefined) {
                localVarQueryParameter["ExcludeItemTypes"] = excludeItemTypes;
            }
            if (includeItemTypes !== undefined) {
                localVarQueryParameter["IncludeItemTypes"] = includeItemTypes;
            }
            if (anyProviderIdEquals !== undefined) {
                localVarQueryParameter["AnyProviderIdEquals"] = anyProviderIdEquals;
            }
            if (filters !== undefined) {
                localVarQueryParameter["Filters"] = filters;
            }
            if (isFavorite !== undefined) {
                localVarQueryParameter["IsFavorite"] = isFavorite;
            }
            if (isMovie !== undefined) {
                localVarQueryParameter["IsMovie"] = isMovie;
            }
            if (isSeries !== undefined) {
                localVarQueryParameter["IsSeries"] = isSeries;
            }
            if (isNews !== undefined) {
                localVarQueryParameter["IsNews"] = isNews;
            }
            if (isKids !== undefined) {
                localVarQueryParameter["IsKids"] = isKids;
            }
            if (isSports !== undefined) {
                localVarQueryParameter["IsSports"] = isSports;
            }
            if (mediaTypes !== undefined) {
                localVarQueryParameter["MediaTypes"] = mediaTypes;
            }
            if (imageTypes !== undefined) {
                localVarQueryParameter["ImageTypes"] = imageTypes;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter["SortBy"] = sortBy;
            }
            if (isPlayed !== undefined) {
                localVarQueryParameter["IsPlayed"] = isPlayed;
            }
            if (genres !== undefined) {
                localVarQueryParameter["Genres"] = genres;
            }
            if (officialRatings !== undefined) {
                localVarQueryParameter["OfficialRatings"] = officialRatings;
            }
            if (tags !== undefined) {
                localVarQueryParameter["Tags"] = tags;
            }
            if (years !== undefined) {
                localVarQueryParameter["Years"] = years;
            }
            if (enableImages !== undefined) {
                localVarQueryParameter["EnableImages"] = enableImages;
            }
            if (enableUserData !== undefined) {
                localVarQueryParameter["EnableUserData"] = enableUserData;
            }
            if (imageTypeLimit !== undefined) {
                localVarQueryParameter["ImageTypeLimit"] = imageTypeLimit;
            }
            if (enableImageTypes !== undefined) {
                localVarQueryParameter["EnableImageTypes"] = enableImageTypes;
            }
            if (person !== undefined) {
                localVarQueryParameter["Person"] = person;
            }
            if (personIds !== undefined) {
                localVarQueryParameter["PersonIds"] = personIds;
            }
            if (personTypes !== undefined) {
                localVarQueryParameter["PersonTypes"] = personTypes;
            }
            if (studios !== undefined) {
                localVarQueryParameter["Studios"] = studios;
            }
            if (studioIds !== undefined) {
                localVarQueryParameter["StudioIds"] = studioIds;
            }
            if (artists !== undefined) {
                localVarQueryParameter["Artists"] = artists;
            }
            if (artistIds !== undefined) {
                localVarQueryParameter["ArtistIds"] = artistIds;
            }
            if (albums !== undefined) {
                localVarQueryParameter["Albums"] = albums;
            }
            if (ids !== undefined) {
                localVarQueryParameter["Ids"] = ids;
            }
            if (videoTypes !== undefined) {
                localVarQueryParameter["VideoTypes"] = videoTypes;
            }
            if (containers !== undefined) {
                localVarQueryParameter["Containers"] = containers;
            }
            if (audioCodecs !== undefined) {
                localVarQueryParameter["AudioCodecs"] = audioCodecs;
            }
            if (videoCodecs !== undefined) {
                localVarQueryParameter["VideoCodecs"] = videoCodecs;
            }
            if (subtitleCodecs !== undefined) {
                localVarQueryParameter["SubtitleCodecs"] = subtitleCodecs;
            }
            if (path !== undefined) {
                localVarQueryParameter["Path"] = path;
            }
            if (userId !== undefined) {
                localVarQueryParameter["UserId"] = userId;
            }
            if (minOfficialRating !== undefined) {
                localVarQueryParameter["MinOfficialRating"] = minOfficialRating;
            }
            if (isLocked !== undefined) {
                localVarQueryParameter["IsLocked"] = isLocked;
            }
            if (isPlaceHolder !== undefined) {
                localVarQueryParameter["IsPlaceHolder"] = isPlaceHolder;
            }
            if (hasOfficialRating !== undefined) {
                localVarQueryParameter["HasOfficialRating"] = hasOfficialRating;
            }
            if (groupItemsIntoCollections !== undefined) {
                localVarQueryParameter["GroupItemsIntoCollections"] =
                    groupItemsIntoCollections;
            }
            if (is3D !== undefined) {
                localVarQueryParameter["Is3D"] = is3D;
            }
            if (seriesStatus !== undefined) {
                localVarQueryParameter["SeriesStatus"] = seriesStatus;
            }
            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter["NameStartsWithOrGreater"] =
                    nameStartsWithOrGreater;
            }
            if (nameStartsWith !== undefined) {
                localVarQueryParameter["NameStartsWith"] = nameStartsWith;
            }
            if (nameLessThan !== undefined) {
                localVarQueryParameter["NameLessThan"] = nameLessThan;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv recording
         * @param {string} id Recording Id
         * @param {string} [userId] Optional attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsById: async (id, userId, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling getLivetvRecordingsById.");
            }
            const localVarPath = `/LiveTv/Recordings/{Id}`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (userId !== undefined) {
                localVarQueryParameter["UserId"] = userId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets recording folders
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsFolders: async (userId, options = {}) => {
            const localVarPath = `/LiveTv/Recordings/Folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (userId !== undefined) {
                localVarQueryParameter["UserId"] = userId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recording groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsGroups: async (options = {}) => {
            const localVarPath = `/LiveTv/Recordings/Groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recordings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsSeries: async (options = {}) => {
            const localVarPath = `/LiveTv/Recordings/Series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv series timers
         * @param {string} [sortBy] Optional. Sort by SortName or Priority
         * @param {string} [sortOrder] Optional. Sort in Ascending or Descending order
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvSeriestimers: async (sortBy, sortOrder, startIndex, limit, options = {}) => {
            const localVarPath = `/LiveTv/SeriesTimers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (sortBy !== undefined) {
                localVarQueryParameter["SortBy"] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter["SortOrder"] = sortOrder;
            }
            if (startIndex !== undefined) {
                localVarQueryParameter["StartIndex"] = startIndex;
            }
            if (limit !== undefined) {
                localVarQueryParameter["Limit"] = limit;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv series timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvSeriestimersById: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling getLivetvSeriestimersById.");
            }
            const localVarPath = `/LiveTv/SeriesTimers/{Id}`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv timers
         * @param {string} [channelId] Optional filter by channel id.
         * @param {string} [seriesTimerId] Optional filter by timers belonging to a series timer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTimers: async (channelId, seriesTimerId, options = {}) => {
            const localVarPath = `/LiveTv/Timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (channelId !== undefined) {
                localVarQueryParameter["ChannelId"] = channelId;
            }
            if (seriesTimerId !== undefined) {
                localVarQueryParameter["SeriesTimerId"] = seriesTimerId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTimersById: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling getLivetvTimersById.");
            }
            const localVarPath = `/LiveTv/Timers/{Id}`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets default values for a new timer
         * @param {string} [programId] Optional, to attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTimersDefaults: async (programId, options = {}) => {
            const localVarPath = `/LiveTv/Timers/Defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (programId !== undefined) {
                localVarQueryParameter["ProgramId"] = programId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets tuner hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTunerhosts: async (options = {}) => {
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTunerhostsTypes: async (options = {}) => {
            const localVarPath = `/LiveTv/TunerHosts/Types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTunersDiscvover: async (options = {}) => {
            const localVarPath = `/LiveTv/Tuners/Discvover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headLivetvChannelmappingoptions: async (providerId, options = {}) => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling headLivetvChannelmappingoptions.");
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headLivetvChannelmappings: async (providerId, options = {}) => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling headLivetvChannelmappings.");
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "HEAD" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsLivetvChannelmappingoptions: async (providerId, options = {}) => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling optionsLivetvChannelmappingoptions.");
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "OPTIONS" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsLivetvChannelmappings: async (providerId, options = {}) => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling optionsLivetvChannelmappings.");
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "OPTIONS" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchLivetvChannelmappingoptions: async (providerId, options = {}) => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling patchLivetvChannelmappingoptions.");
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchLivetvChannelmappings: async (providerId, options = {}) => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling patchLivetvChannelmappings.");
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvChannelmappingoptions: async (providerId, options = {}) => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling postLivetvChannelmappingoptions.");
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvChannelmappings: async (body, providerId, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postLivetvChannelmappings.");
            }
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling postLivetvChannelmappings.");
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Adds a listing provider
         * @param {LiveTvListingsProviderInfo} body ListingsProviderInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvListingproviders: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postLivetvListingproviders.");
            }
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Sets a channel disabled or not
         * @param {LiveTVApiSetChannelDisabled} body SetChannelDisabled
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvManageChannelsByIdDisabled: async (body, id, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postLivetvManageChannelsByIdDisabled.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postLivetvManageChannelsByIdDisabled.");
            }
            const localVarPath = `/LiveTv/Manage/Channels/{Id}/Disabled`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Sets a channel sort index
         * @param {LiveTVApiSetChannelSortIndex} body SetChannelSortIndex
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvManageChannelsByIdSortindex: async (body, id, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postLivetvManageChannelsByIdSortindex.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postLivetvManageChannelsByIdSortindex.");
            }
            const localVarPath = `/LiveTv/Manage/Channels/{Id}/SortIndex`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {LiveTVApiGetPrograms} body GetPrograms
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvPrograms: async (body, channelIds, userId, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, genreIds, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postLivetvPrograms.");
            }
            const localVarPath = `/LiveTv/Programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (channelIds !== undefined) {
                localVarQueryParameter["ChannelIds"] = channelIds;
            }
            if (userId !== undefined) {
                localVarQueryParameter["UserId"] = userId;
            }
            if (minStartDate !== undefined) {
                localVarQueryParameter["MinStartDate"] = minStartDate;
            }
            if (maxStartDate !== undefined) {
                localVarQueryParameter["MaxStartDate"] = maxStartDate;
            }
            if (minEndDate !== undefined) {
                localVarQueryParameter["MinEndDate"] = minEndDate;
            }
            if (maxEndDate !== undefined) {
                localVarQueryParameter["MaxEndDate"] = maxEndDate;
            }
            if (isMovie !== undefined) {
                localVarQueryParameter["IsMovie"] = isMovie;
            }
            if (isSeries !== undefined) {
                localVarQueryParameter["IsSeries"] = isSeries;
            }
            if (isNews !== undefined) {
                localVarQueryParameter["IsNews"] = isNews;
            }
            if (isKids !== undefined) {
                localVarQueryParameter["IsKids"] = isKids;
            }
            if (isSports !== undefined) {
                localVarQueryParameter["IsSports"] = isSports;
            }
            if (genreIds !== undefined) {
                localVarQueryParameter["GenreIds"] = genreIds;
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Creates a live tv series timer
         * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvSeriestimers: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postLivetvSeriestimers.");
            }
            const localVarPath = `/LiveTv/SeriesTimers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates a live tv series timer
         * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto:
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvSeriestimersById: async (body, id, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postLivetvSeriestimersById.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postLivetvSeriestimersById.");
            }
            const localVarPath = `/LiveTv/SeriesTimers/{Id}`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Creates a live tv timer
         * @param {LiveTvTimerInfoDto} body TimerInfoDto:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTimers: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postLivetvTimers.");
            }
            const localVarPath = `/LiveTv/Timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates a live tv timer
         * @param {LiveTvTimerInfoDto} body TimerInfoDto:
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTimersById: async (body, id, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postLivetvTimersById.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postLivetvTimersById.");
            }
            const localVarPath = `/LiveTv/Timers/{Id}`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Adds a tuner host
         * @param {LiveTvTunerHostInfo} body TunerHostInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTunerhosts: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postLivetvTunerhosts.");
            }
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Resets a tv tuner
         * @param {string} id Tuner Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTunersByIdReset: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postLivetvTunersByIdReset.");
            }
            const localVarPath = `/LiveTv/Tuners/{Id}/Reset`.replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLivetvChannelmappingoptions: async (providerId, options = {}) => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling putLivetvChannelmappingoptions.");
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLivetvChannelmappings: async (body, providerId, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling putLivetvChannelmappings.");
            }
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new base_1.RequiredError("providerId", "Required parameter providerId was null or undefined when calling putLivetvChannelmappings.");
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (providerId !== undefined) {
                localVarQueryParameter["ProviderId"] = providerId;
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    };
};
exports.LiveTvServiceApiAxiosParamCreator = LiveTvServiceApiAxiosParamCreator;
/**
 * LiveTvServiceApi - functional programming interface
 * @export
 */
const LiveTvServiceApiFp = function (configuration) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvChannelmappingoptions(providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).deleteLivetvChannelmappingoptions(providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvChannelmappings(providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).deleteLivetvChannelmappings(providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Deletes a listing provider
         * @param {string} [id] Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvListingproviders(id, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).deleteLivetvListingproviders(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Deletes a live tv recording
         * @param {string} id Recording Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvRecordingsById(id, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).deleteLivetvRecordingsById(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Cancels a live tv series timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvSeriestimersById(id, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).deleteLivetvSeriestimersById(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Cancels a live tv timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvTimersById(id, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).deleteLivetvTimersById(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Deletes a tuner host
         * @param {string} [id] Tuner host id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvTunerhosts(id, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).deleteLivetvTunerhosts(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvChannelmappingoptions(providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvChannelmappingoptions(providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvChannelmappings(providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvChannelmappings(providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv channels.
         * @param {string} [type] Optional filter by channel type.
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
         * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv channel
         * @param {string} id Channel Id
         * @param {string} [userId] Optional attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvChannelsById(id, userId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvChannelsById(id, userId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @summary Gets live tv channel tags
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvChanneltags(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvChanneltags(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @summary Gets live tv channel tag prefixes
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvChanneltagsPrefixes(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvChanneltagsPrefixes(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets the epg.
         * @param {string} [type] Optional filter by channel type.
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
         * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvEPG(type, userId, genreIds, minStartDate, maxStartDate, minEndDate, maxEndDate, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, channelIds, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvEPG(type, userId, genreIds, minStartDate, maxStartDate, minEndDate, maxEndDate, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, channelIds, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets the top level live tv folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvFolder(options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvFolder(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets guide info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvGuideinfo(options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvGuideinfo(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvInfo(options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvInfo(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets current listing providers
         * @param {string} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvListingproviders(channelId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvListingproviders(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets listing provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvListingprovidersAvailable(options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvListingprovidersAvailable(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvListingprovidersDefault(options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvListingprovidersDefault(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets available lineups
         * @param {string} [id] Provider id
         * @param {string} [type] Provider Type
         * @param {string} [location] Location
         * @param {string} [country] Country
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvListingprovidersLineups(id, type, location, country, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvListingprovidersLineups(id, type, location, country, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets available lineups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvListingprovidersSchedulesdirectCountries(options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvListingprovidersSchedulesdirectCountries(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @summary Gets a live tv channel
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvLiverecordingsByIdStream(id, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvLiverecordingsByIdStream(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @summary Gets a live tv channel
         * @param {string} id
         * @param {string} container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvLivestreamfilesByIdByContainer(id, container, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvLivestreamfilesByIdByContainer(id, container, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets the channel management list
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvManageChannels(startIndex, limit, sortBy, sortOrder, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvManageChannels(startIndex, limit, sortBy, sortOrder, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional filter by user id.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvPrograms(channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvPrograms(channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {string} [userId] Optional filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvProgramsRecommended(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvProgramsRecommended(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recordings
         * @param {string} [channelId] Optional filter by channel id.
         * @param {string} [status] Optional filter by recording status.
         * @param {boolean} [isInProgress] Optional filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional filter by recordings belonging to a series timer
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvRecordings(channelId, status, isInProgress, seriesTimerId, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvRecordings(channelId, status, isInProgress, seriesTimerId, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv recording
         * @param {string} id Recording Id
         * @param {string} [userId] Optional attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvRecordingsById(id, userId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvRecordingsById(id, userId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets recording folders
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvRecordingsFolders(userId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvRecordingsFolders(userId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recording groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvRecordingsGroups(options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvRecordingsGroups(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recordings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvRecordingsSeries(options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvRecordingsSeries(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv series timers
         * @param {string} [sortBy] Optional. Sort by SortName or Priority
         * @param {string} [sortOrder] Optional. Sort in Ascending or Descending order
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvSeriestimers(sortBy, sortOrder, startIndex, limit, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvSeriestimers(sortBy, sortOrder, startIndex, limit, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv series timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvSeriestimersById(id, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvSeriestimersById(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv timers
         * @param {string} [channelId] Optional filter by channel id.
         * @param {string} [seriesTimerId] Optional filter by timers belonging to a series timer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvTimers(channelId, seriesTimerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvTimers(channelId, seriesTimerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvTimersById(id, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvTimersById(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets default values for a new timer
         * @param {string} [programId] Optional, to attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvTimersDefaults(programId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvTimersDefaults(programId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets tuner hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvTunerhosts(options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvTunerhosts(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvTunerhostsTypes(options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvTunerhostsTypes(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvTunersDiscvover(options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).getLivetvTunersDiscvover(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headLivetvChannelmappingoptions(providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).headLivetvChannelmappingoptions(providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headLivetvChannelmappings(providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).headLivetvChannelmappings(providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsLivetvChannelmappingoptions(providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).optionsLivetvChannelmappingoptions(providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsLivetvChannelmappings(providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).optionsLivetvChannelmappings(providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchLivetvChannelmappingoptions(providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).patchLivetvChannelmappingoptions(providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchLivetvChannelmappings(providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).patchLivetvChannelmappings(providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvChannelmappingoptions(providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).postLivetvChannelmappingoptions(providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvChannelmappings(body, providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).postLivetvChannelmappings(body, providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Adds a listing provider
         * @param {LiveTvListingsProviderInfo} body ListingsProviderInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvListingproviders(body, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).postLivetvListingproviders(body, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Sets a channel disabled or not
         * @param {LiveTVApiSetChannelDisabled} body SetChannelDisabled
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvManageChannelsByIdDisabled(body, id, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).postLivetvManageChannelsByIdDisabled(body, id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Sets a channel sort index
         * @param {LiveTVApiSetChannelSortIndex} body SetChannelSortIndex
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvManageChannelsByIdSortindex(body, id, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).postLivetvManageChannelsByIdSortindex(body, id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {LiveTVApiGetPrograms} body GetPrograms
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvPrograms(body, channelIds, userId, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, genreIds, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).postLivetvPrograms(body, channelIds, userId, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, genreIds, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Creates a live tv series timer
         * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvSeriestimers(body, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).postLivetvSeriestimers(body, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates a live tv series timer
         * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto:
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvSeriestimersById(body, id, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).postLivetvSeriestimersById(body, id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Creates a live tv timer
         * @param {LiveTvTimerInfoDto} body TimerInfoDto:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvTimers(body, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).postLivetvTimers(body, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates a live tv timer
         * @param {LiveTvTimerInfoDto} body TimerInfoDto:
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvTimersById(body, id, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).postLivetvTimersById(body, id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Adds a tuner host
         * @param {LiveTvTunerHostInfo} body TunerHostInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvTunerhosts(body, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).postLivetvTunerhosts(body, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Resets a tv tuner
         * @param {string} id Tuner Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvTunersByIdReset(id, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).postLivetvTunersByIdReset(id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLivetvChannelmappingoptions(providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).putLivetvChannelmappingoptions(providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLivetvChannelmappings(body, providerId, options) {
            const localVarAxiosArgs = await (0, exports.LiveTvServiceApiAxiosParamCreator)(configuration).putLivetvChannelmappings(body, providerId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
exports.LiveTvServiceApiFp = LiveTvServiceApiFp;
/**
 * LiveTvServiceApi - factory interface
 * @export
 */
const LiveTvServiceApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvChannelmappingoptions(providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .deleteLivetvChannelmappingoptions(providerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvChannelmappings(providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .deleteLivetvChannelmappings(providerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Deletes a listing provider
         * @param {string} [id] Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvListingproviders(id, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .deleteLivetvListingproviders(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Deletes a live tv recording
         * @param {string} id Recording Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvRecordingsById(id, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .deleteLivetvRecordingsById(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Cancels a live tv series timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvSeriestimersById(id, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .deleteLivetvSeriestimersById(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Cancels a live tv timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvTimersById(id, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .deleteLivetvTimersById(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Deletes a tuner host
         * @param {string} [id] Tuner host id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvTunerhosts(id, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .deleteLivetvTunerhosts(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannelmappingoptions(providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvChannelmappingoptions(providerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannelmappings(providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvChannelmappings(providerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv channels.
         * @param {string} [type] Optional filter by channel type.
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
         * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv channel
         * @param {string} id Channel Id
         * @param {string} [userId] Optional attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannelsById(id, userId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvChannelsById(id, userId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @summary Gets live tv channel tags
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChanneltags(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvChanneltags(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @summary Gets live tv channel tag prefixes
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChanneltagsPrefixes(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvChanneltagsPrefixes(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets the epg.
         * @param {string} [type] Optional filter by channel type.
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
         * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvEPG(type, userId, genreIds, minStartDate, maxStartDate, minEndDate, maxEndDate, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, channelIds, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvEPG(type, userId, genreIds, minStartDate, maxStartDate, minEndDate, maxEndDate, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, channelIds, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets the top level live tv folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvFolder(options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvFolder(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets guide info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvGuideinfo(options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvGuideinfo(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvInfo(options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvInfo(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Gets current listing providers
         * @param {string} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingproviders(channelId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvListingproviders(channelId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Gets listing provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersAvailable(options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvListingprovidersAvailable(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersDefault(options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvListingprovidersDefault(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Gets available lineups
         * @param {string} [id] Provider id
         * @param {string} [type] Provider Type
         * @param {string} [location] Location
         * @param {string} [country] Country
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersLineups(id, type, location, country, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvListingprovidersLineups(id, type, location, country, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Gets available lineups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersSchedulesdirectCountries(options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvListingprovidersSchedulesdirectCountries(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @summary Gets a live tv channel
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvLiverecordingsByIdStream(id, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvLiverecordingsByIdStream(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @summary Gets a live tv channel
         * @param {string} id
         * @param {string} container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvLivestreamfilesByIdByContainer(id, container, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvLivestreamfilesByIdByContainer(id, container, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Gets the channel management list
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvManageChannels(startIndex, limit, sortBy, sortOrder, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvManageChannels(startIndex, limit, sortBy, sortOrder, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional filter by user id.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvPrograms(channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvPrograms(channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {string} [userId] Optional filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvProgramsRecommended(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvProgramsRecommended(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recordings
         * @param {string} [channelId] Optional filter by channel id.
         * @param {string} [status] Optional filter by recording status.
         * @param {boolean} [isInProgress] Optional filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional filter by recordings belonging to a series timer
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordings(channelId, status, isInProgress, seriesTimerId, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvRecordings(channelId, status, isInProgress, seriesTimerId, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv recording
         * @param {string} id Recording Id
         * @param {string} [userId] Optional attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsById(id, userId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvRecordingsById(id, userId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets recording folders
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsFolders(userId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvRecordingsFolders(userId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recording groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsGroups(options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvRecordingsGroups(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recordings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsSeries(options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvRecordingsSeries(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv series timers
         * @param {string} [sortBy] Optional. Sort by SortName or Priority
         * @param {string} [sortOrder] Optional. Sort in Ascending or Descending order
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvSeriestimers(sortBy, sortOrder, startIndex, limit, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvSeriestimers(sortBy, sortOrder, startIndex, limit, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv series timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvSeriestimersById(id, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvSeriestimersById(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv timers
         * @param {string} [channelId] Optional filter by channel id.
         * @param {string} [seriesTimerId] Optional filter by timers belonging to a series timer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTimers(channelId, seriesTimerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvTimers(channelId, seriesTimerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTimersById(id, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvTimersById(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets default values for a new timer
         * @param {string} [programId] Optional, to attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTimersDefaults(programId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvTimersDefaults(programId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Gets tuner hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTunerhosts(options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvTunerhosts(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTunerhostsTypes(options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvTunerhostsTypes(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTunersDiscvover(options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .getLivetvTunersDiscvover(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headLivetvChannelmappingoptions(providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .headLivetvChannelmappingoptions(providerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headLivetvChannelmappings(providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .headLivetvChannelmappings(providerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsLivetvChannelmappingoptions(providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .optionsLivetvChannelmappingoptions(providerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsLivetvChannelmappings(providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .optionsLivetvChannelmappings(providerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchLivetvChannelmappingoptions(providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .patchLivetvChannelmappingoptions(providerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchLivetvChannelmappings(providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .patchLivetvChannelmappings(providerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvChannelmappingoptions(providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .postLivetvChannelmappingoptions(providerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvChannelmappings(body, providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .postLivetvChannelmappings(body, providerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Adds a listing provider
         * @param {LiveTvListingsProviderInfo} body ListingsProviderInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvListingproviders(body, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .postLivetvListingproviders(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Sets a channel disabled or not
         * @param {LiveTVApiSetChannelDisabled} body SetChannelDisabled
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvManageChannelsByIdDisabled(body, id, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .postLivetvManageChannelsByIdDisabled(body, id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Sets a channel sort index
         * @param {LiveTVApiSetChannelSortIndex} body SetChannelSortIndex
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvManageChannelsByIdSortindex(body, id, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .postLivetvManageChannelsByIdSortindex(body, id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {LiveTVApiGetPrograms} body GetPrograms
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvPrograms(body, channelIds, userId, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, genreIds, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .postLivetvPrograms(body, channelIds, userId, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, genreIds, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Creates a live tv series timer
         * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvSeriestimers(body, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .postLivetvSeriestimers(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Updates a live tv series timer
         * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto:
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvSeriestimersById(body, id, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .postLivetvSeriestimersById(body, id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Creates a live tv timer
         * @param {LiveTvTimerInfoDto} body TimerInfoDto:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTimers(body, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .postLivetvTimers(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Updates a live tv timer
         * @param {LiveTvTimerInfoDto} body TimerInfoDto:
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTimersById(body, id, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .postLivetvTimersById(body, id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Adds a tuner host
         * @param {LiveTvTunerHostInfo} body TunerHostInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTunerhosts(body, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .postLivetvTunerhosts(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Resets a tv tuner
         * @param {string} id Tuner Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTunersByIdReset(id, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .postLivetvTunersByIdReset(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLivetvChannelmappingoptions(providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .putLivetvChannelmappingoptions(providerId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLivetvChannelmappings(body, providerId, options) {
            return (0, exports.LiveTvServiceApiFp)(configuration)
                .putLivetvChannelmappings(body, providerId, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.LiveTvServiceApiFactory = LiveTvServiceApiFactory;
/**
 * LiveTvServiceApi - object-oriented interface
 * @export
 * @class LiveTvServiceApi
 * @extends {BaseAPI}
 */
class LiveTvServiceApi extends base_1.BaseAPI {
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    deleteLivetvChannelmappingoptions(providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .deleteLivetvChannelmappingoptions(providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    deleteLivetvChannelmappings(providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .deleteLivetvChannelmappings(providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Deletes a listing provider
     * @param {string} [id] Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    deleteLivetvListingproviders(id, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .deleteLivetvListingproviders(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Deletes a live tv recording
     * @param {string} id Recording Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    deleteLivetvRecordingsById(id, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .deleteLivetvRecordingsById(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Cancels a live tv series timer
     * @param {string} id Timer Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    deleteLivetvSeriestimersById(id, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .deleteLivetvSeriestimersById(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Cancels a live tv timer
     * @param {string} id Timer Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    deleteLivetvTimersById(id, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .deleteLivetvTimersById(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Deletes a tuner host
     * @param {string} [id] Tuner host id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    deleteLivetvTunerhosts(id, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .deleteLivetvTunerhosts(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvChannelmappingoptions(providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvChannelmappingoptions(providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvChannelmappings(providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvChannelmappings(providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets available live tv channels.
     * @param {string} [type] Optional filter by channel type.
     * @param {string} [userId] Optional filter by user and attach user data.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
     * @param {boolean} [isLiked] Filter by channels that are liked, or not.
     * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
     * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets a live tv channel
     * @param {string} id Channel Id
     * @param {string} [userId] Optional attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvChannelsById(id, userId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvChannelsById(id, userId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @summary Gets live tv channel tags
     * @param {string} [artistType] Artist or AlbumArtist
     * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
     * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
     * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
     * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
     * @param {boolean} [hasTrailer] Optional filter by items with trailers.
     * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
     * @param {number} [minIndexNumber] Optional filter by minimum index number.
     * @param {number} [minPlayers] Optional filter by minimum number of game players.
     * @param {number} [maxPlayers] Optional filter by maximum number of game players.
     * @param {number} [parentIndexNumber] Optional filter by parent index number.
     * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
     * @param {boolean} [isHD] Optional filter by items that are HD or not.
     * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
     * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [minCriticRating] Optional filter by minimum critic rating.
     * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
     * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
     * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
     * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
     * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
     * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param {string} [searchTerm] Enter a search term to perform a search request
     * @param {string} [sortOrder] Sort Order - Ascending,Descending
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
     * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
     * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param {string} [path] Optional filter by Path.
     * @param {string} [userId] User Id
     * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [isLocked] Optional filter by items that are locked.
     * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
     * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
     * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
     * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
     * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvChanneltags(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvChanneltags(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @summary Gets live tv channel tag prefixes
     * @param {string} [artistType] Artist or AlbumArtist
     * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
     * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
     * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
     * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
     * @param {boolean} [hasTrailer] Optional filter by items with trailers.
     * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
     * @param {number} [minIndexNumber] Optional filter by minimum index number.
     * @param {number} [minPlayers] Optional filter by minimum number of game players.
     * @param {number} [maxPlayers] Optional filter by maximum number of game players.
     * @param {number} [parentIndexNumber] Optional filter by parent index number.
     * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
     * @param {boolean} [isHD] Optional filter by items that are HD or not.
     * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
     * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [minCriticRating] Optional filter by minimum critic rating.
     * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
     * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
     * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
     * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
     * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
     * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param {string} [searchTerm] Enter a search term to perform a search request
     * @param {string} [sortOrder] Sort Order - Ascending,Descending
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
     * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
     * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param {string} [path] Optional filter by Path.
     * @param {string} [userId] User Id
     * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [isLocked] Optional filter by items that are locked.
     * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
     * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
     * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
     * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
     * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvChanneltagsPrefixes(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvChanneltagsPrefixes(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets the epg.
     * @param {string} [type] Optional filter by channel type.
     * @param {string} [userId] Optional filter by user and attach user data.
     * @param {string} [genreIds] The genres to return guide information for.
     * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
     * @param {boolean} [isLiked] Filter by channels that are liked, or not.
     * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
     * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {string} [channelIds] The channels to return guide information for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvEPG(type, userId, genreIds, minStartDate, maxStartDate, minEndDate, maxEndDate, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, channelIds, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvEPG(type, userId, genreIds, minStartDate, maxStartDate, minEndDate, maxEndDate, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, channelIds, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets the top level live tv folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvFolder(options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvFolder(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets guide info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvGuideinfo(options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvGuideinfo(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets available live tv services.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvInfo(options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvInfo(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Gets current listing providers
     * @param {string} channelId Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvListingproviders(channelId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvListingproviders(channelId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Gets listing provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvListingprovidersAvailable(options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvListingprovidersAvailable(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvListingprovidersDefault(options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvListingprovidersDefault(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Gets available lineups
     * @param {string} [id] Provider id
     * @param {string} [type] Provider Type
     * @param {string} [location] Location
     * @param {string} [country] Country
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvListingprovidersLineups(id, type, location, country, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvListingprovidersLineups(id, type, location, country, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Gets available lineups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvListingprovidersSchedulesdirectCountries(options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvListingprovidersSchedulesdirectCountries(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @summary Gets a live tv channel
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvLiverecordingsByIdStream(id, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvLiverecordingsByIdStream(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @summary Gets a live tv channel
     * @param {string} id
     * @param {string} container
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvLivestreamfilesByIdByContainer(id, container, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvLivestreamfilesByIdByContainer(id, container, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Gets the channel management list
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
     * @param {string} [sortOrder] Sort Order - Ascending,Descending
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvManageChannels(startIndex, limit, sortBy, sortOrder, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvManageChannels(startIndex, limit, sortBy, sortOrder, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets available live tv epgs..
     * @param {string} [channelIds] The channels to return guide information for.
     * @param {string} [userId] Optional filter by user id.
     * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
     * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
     * @param {string} [sortOrder] Sort Order - Ascending,Descending
     * @param {string} [genreIds] The genres to return guide information for.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvPrograms(channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvPrograms(channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets available live tv epgs..
     * @param {string} [userId] Optional filter by user id.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
     * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [genreIds] The genres to return guide information for.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvProgramsRecommended(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvProgramsRecommended(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets live tv recordings
     * @param {string} [channelId] Optional filter by channel id.
     * @param {string} [status] Optional filter by recording status.
     * @param {boolean} [isInProgress] Optional filter by recordings that are in progress, or not.
     * @param {string} [seriesTimerId] Optional filter by recordings belonging to a series timer
     * @param {string} [artistType] Artist or AlbumArtist
     * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
     * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
     * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
     * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
     * @param {boolean} [hasTrailer] Optional filter by items with trailers.
     * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
     * @param {number} [minIndexNumber] Optional filter by minimum index number.
     * @param {number} [minPlayers] Optional filter by minimum number of game players.
     * @param {number} [maxPlayers] Optional filter by maximum number of game players.
     * @param {number} [parentIndexNumber] Optional filter by parent index number.
     * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
     * @param {boolean} [isHD] Optional filter by items that are HD or not.
     * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
     * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [minCriticRating] Optional filter by minimum critic rating.
     * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
     * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
     * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
     * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
     * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
     * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param {string} [searchTerm] Enter a search term to perform a search request
     * @param {string} [sortOrder] Sort Order - Ascending,Descending
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
     * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
     * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param {string} [path] Optional filter by Path.
     * @param {string} [userId] User Id
     * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [isLocked] Optional filter by items that are locked.
     * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
     * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
     * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
     * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
     * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvRecordings(channelId, status, isInProgress, seriesTimerId, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvRecordings(channelId, status, isInProgress, seriesTimerId, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets a live tv recording
     * @param {string} id Recording Id
     * @param {string} [userId] Optional attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvRecordingsById(id, userId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvRecordingsById(id, userId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets recording folders
     * @param {string} [userId] Optional filter by user and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvRecordingsFolders(userId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvRecordingsFolders(userId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets live tv recording groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvRecordingsGroups(options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvRecordingsGroups(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets live tv recordings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvRecordingsSeries(options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvRecordingsSeries(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets live tv series timers
     * @param {string} [sortBy] Optional. Sort by SortName or Priority
     * @param {string} [sortOrder] Optional. Sort in Ascending or Descending order
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvSeriestimers(sortBy, sortOrder, startIndex, limit, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvSeriestimers(sortBy, sortOrder, startIndex, limit, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets a live tv series timer
     * @param {string} id Timer Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvSeriestimersById(id, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvSeriestimersById(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets live tv timers
     * @param {string} [channelId] Optional filter by channel id.
     * @param {string} [seriesTimerId] Optional filter by timers belonging to a series timer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvTimers(channelId, seriesTimerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvTimers(channelId, seriesTimerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets a live tv timer
     * @param {string} id Timer Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvTimersById(id, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvTimersById(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets default values for a new timer
     * @param {string} [programId] Optional, to attach default values based on a program.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvTimersDefaults(programId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvTimersDefaults(programId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Gets tuner hosts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvTunerhosts(options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvTunerhosts(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvTunerhostsTypes(options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvTunerhostsTypes(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    getLivetvTunersDiscvover(options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .getLivetvTunersDiscvover(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    headLivetvChannelmappingoptions(providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .headLivetvChannelmappingoptions(providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    headLivetvChannelmappings(providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .headLivetvChannelmappings(providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    optionsLivetvChannelmappingoptions(providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .optionsLivetvChannelmappingoptions(providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    optionsLivetvChannelmappings(providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .optionsLivetvChannelmappings(providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    patchLivetvChannelmappingoptions(providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .patchLivetvChannelmappingoptions(providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    patchLivetvChannelmappings(providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .patchLivetvChannelmappings(providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    postLivetvChannelmappingoptions(providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .postLivetvChannelmappingoptions(providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    postLivetvChannelmappings(body, providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .postLivetvChannelmappings(body, providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Adds a listing provider
     * @param {LiveTvListingsProviderInfo} body ListingsProviderInfo:
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    postLivetvListingproviders(body, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .postLivetvListingproviders(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Sets a channel disabled or not
     * @param {LiveTVApiSetChannelDisabled} body SetChannelDisabled
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    postLivetvManageChannelsByIdDisabled(body, id, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .postLivetvManageChannelsByIdDisabled(body, id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Sets a channel sort index
     * @param {LiveTVApiSetChannelSortIndex} body SetChannelSortIndex
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    postLivetvManageChannelsByIdSortindex(body, id, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .postLivetvManageChannelsByIdSortindex(body, id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets available live tv epgs..
     * @param {LiveTVApiGetPrograms} body GetPrograms
     * @param {string} [channelIds] The channels to return guide information for.
     * @param {string} [userId] Optional filter by user id.
     * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {string} [genreIds] The genres to return guide information for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    postLivetvPrograms(body, channelIds, userId, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, genreIds, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .postLivetvPrograms(body, channelIds, userId, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, genreIds, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Creates a live tv series timer
     * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto:
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    postLivetvSeriestimers(body, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .postLivetvSeriestimers(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Updates a live tv series timer
     * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto:
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    postLivetvSeriestimersById(body, id, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .postLivetvSeriestimersById(body, id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Creates a live tv timer
     * @param {LiveTvTimerInfoDto} body TimerInfoDto:
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    postLivetvTimers(body, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .postLivetvTimers(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Updates a live tv timer
     * @param {LiveTvTimerInfoDto} body TimerInfoDto:
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    postLivetvTimersById(body, id, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .postLivetvTimersById(body, id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Adds a tuner host
     * @param {LiveTvTunerHostInfo} body TunerHostInfo:
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    postLivetvTunerhosts(body, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .postLivetvTunerhosts(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Resets a tv tuner
     * @param {string} id Tuner Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    postLivetvTunersByIdReset(id, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .postLivetvTunersByIdReset(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    putLivetvChannelmappingoptions(providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .putLivetvChannelmappingoptions(providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    putLivetvChannelmappings(body, providerId, options) {
        return (0, exports.LiveTvServiceApiFp)(this.configuration)
            .putLivetvChannelmappings(body, providerId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.LiveTvServiceApi = LiveTvServiceApi;
//# sourceMappingURL=live-tv-service-api.js.map