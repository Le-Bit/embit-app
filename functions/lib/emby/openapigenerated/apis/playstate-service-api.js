"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlaystateServiceApi = exports.PlaystateServiceApiFactory = exports.PlaystateServiceApiFp = exports.PlaystateServiceApiAxiosParamCreator = void 0;
/* tslint:disable */
/* eslint-disable */
/**
 * Emby Server API
 * Explore the Emby Server API
 *
 * OpenAPI spec version: 4.7.0.17
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("../base");
/**
 * PlaystateServiceApi - axios parameter creator
 * @export
 */
const PlaystateServiceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Requires authentication as user
         * @summary Marks an item as unplayed
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByUseridPlayeditemsById: async (userId, id, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError("userId", "Required parameter userId was null or undefined when calling deleteUsersByUseridPlayeditemsById.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling deleteUsersByUseridPlayeditemsById.");
            }
            const localVarPath = `/Users/{UserId}/PlayedItems/{Id}`
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that a user has stopped playing an item
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {string} nextMediaType The next media type that will play
         * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms
         * @param {string} [liveStreamId]
         * @param {string} [playSessionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByUseridPlayingitemsById: async (userId, id, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError("userId", "Required parameter userId was null or undefined when calling deleteUsersByUseridPlayingitemsById.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling deleteUsersByUseridPlayingitemsById.");
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new base_1.RequiredError("mediaSourceId", "Required parameter mediaSourceId was null or undefined when calling deleteUsersByUseridPlayingitemsById.");
            }
            // verify required parameter 'nextMediaType' is not null or undefined
            if (nextMediaType === null || nextMediaType === undefined) {
                throw new base_1.RequiredError("nextMediaType", "Required parameter nextMediaType was null or undefined when calling deleteUsersByUseridPlayingitemsById.");
            }
            const localVarPath = `/Users/{UserId}/PlayingItems/{Id}`
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (mediaSourceId !== undefined) {
                localVarQueryParameter["MediaSourceId"] = mediaSourceId;
            }
            if (nextMediaType !== undefined) {
                localVarQueryParameter["NextMediaType"] = nextMediaType;
            }
            if (positionTicks !== undefined) {
                localVarQueryParameter["PositionTicks"] = positionTicks;
            }
            if (liveStreamId !== undefined) {
                localVarQueryParameter["LiveStreamId"] = liveStreamId;
            }
            if (playSessionId !== undefined) {
                localVarQueryParameter["PlaySessionId"] = playSessionId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports playback has started within a session
         * @param {PlaybackStartInfo} body PlaybackStartInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlaying: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postSessionsPlaying.");
            }
            const localVarPath = `/Sessions/Playing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Pings a playback session
         * @param {string} [playSessionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlayingPing: async (playSessionId, options = {}) => {
            const localVarPath = `/Sessions/Playing/Ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (playSessionId !== undefined) {
                localVarQueryParameter["PlaySessionId"] = playSessionId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports playback progress within a session
         * @param {PlaybackProgressInfo} body PlaybackProgressInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlayingProgress: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postSessionsPlayingProgress.");
            }
            const localVarPath = `/Sessions/Playing/Progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports playback has stopped within a session
         * @param {PlaybackStopInfo} body PlaybackStopInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlayingStopped: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postSessionsPlayingStopped.");
            }
            const localVarPath = `/Sessions/Playing/Stopped`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates userdata for an item
         * @param {UserItemDataDto} body UserItemDataDto:
         * @param {string} userId User Id
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridItemsByItemidUserdata: async (body, userId, itemId, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postUsersByUseridItemsByItemidUserdata.");
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError("userId", "Required parameter userId was null or undefined when calling postUsersByUseridItemsByItemidUserdata.");
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new base_1.RequiredError("itemId", "Required parameter itemId was null or undefined when calling postUsersByUseridItemsByItemidUserdata.");
            }
            const localVarPath = `/Users/{UserId}/Items/{ItemId}/UserData`
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"ItemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Marks an item as played
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} [datePlayed] The date the item was played (if any). Format &#x3D; yyyyMMddHHmmss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridPlayeditemsById: async (userId, id, datePlayed, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError("userId", "Required parameter userId was null or undefined when calling postUsersByUseridPlayeditemsById.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postUsersByUseridPlayeditemsById.");
            }
            const localVarPath = `/Users/{UserId}/PlayedItems/{Id}`
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (datePlayed !== undefined) {
                localVarQueryParameter["DatePlayed"] = datePlayed;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that a user has begun playing an item
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {boolean} [canSeek] Indicates if the client can seek
         * @param {number} [audioStreamIndex]
         * @param {number} [subtitleStreamIndex]
         * @param {string} [playMethod]
         * @param {string} [liveStreamId]
         * @param {string} [playSessionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridPlayingitemsById: async (userId, id, mediaSourceId, canSeek, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError("userId", "Required parameter userId was null or undefined when calling postUsersByUseridPlayingitemsById.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postUsersByUseridPlayingitemsById.");
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new base_1.RequiredError("mediaSourceId", "Required parameter mediaSourceId was null or undefined when calling postUsersByUseridPlayingitemsById.");
            }
            const localVarPath = `/Users/{UserId}/PlayingItems/{Id}`
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (mediaSourceId !== undefined) {
                localVarQueryParameter["MediaSourceId"] = mediaSourceId;
            }
            if (canSeek !== undefined) {
                localVarQueryParameter["CanSeek"] = canSeek;
            }
            if (audioStreamIndex !== undefined) {
                localVarQueryParameter["AudioStreamIndex"] = audioStreamIndex;
            }
            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter["SubtitleStreamIndex"] = subtitleStreamIndex;
            }
            if (playMethod !== undefined) {
                localVarQueryParameter["PlayMethod"] = playMethod;
            }
            if (liveStreamId !== undefined) {
                localVarQueryParameter["LiveStreamId"] = liveStreamId;
            }
            if (playSessionId !== undefined) {
                localVarQueryParameter["PlaySessionId"] = playSessionId;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports a user's playback progress
         * @param {MediaEncodingApiOnPlaybackProgress} body OnPlaybackProgress
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms
         * @param {boolean} [isPaused] Indicates if the player is paused.
         * @param {boolean} [isMuted] Indicates if the player is muted.
         * @param {number} [audioStreamIndex]
         * @param {number} [subtitleStreamIndex]
         * @param {number} [volumeLevel] Scale of 0-100
         * @param {string} [playMethod]
         * @param {string} [liveStreamId]
         * @param {string} [playSessionId]
         * @param {string} [repeatMode]
         * @param {number} [subtitleOffset]
         * @param {number} [playbackRate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridPlayingitemsByIdProgress: async (body, mediaSourceId, userId, id, positionTicks, isPaused, isMuted, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, subtitleOffset, playbackRate, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError("body", "Required parameter body was null or undefined when calling postUsersByUseridPlayingitemsByIdProgress.");
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new base_1.RequiredError("mediaSourceId", "Required parameter mediaSourceId was null or undefined when calling postUsersByUseridPlayingitemsByIdProgress.");
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError("userId", "Required parameter userId was null or undefined when calling postUsersByUseridPlayingitemsByIdProgress.");
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError("id", "Required parameter id was null or undefined when calling postUsersByUseridPlayingitemsByIdProgress.");
            }
            const localVarPath = `/Users/{UserId}/PlayingItems/{Id}/Progress`
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, "https://example.com");
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === "function"
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }
            // authentication embyauth required
            if (mediaSourceId !== undefined) {
                localVarQueryParameter["MediaSourceId"] = mediaSourceId;
            }
            if (positionTicks !== undefined) {
                localVarQueryParameter["PositionTicks"] = positionTicks;
            }
            if (isPaused !== undefined) {
                localVarQueryParameter["IsPaused"] = isPaused;
            }
            if (isMuted !== undefined) {
                localVarQueryParameter["IsMuted"] = isMuted;
            }
            if (audioStreamIndex !== undefined) {
                localVarQueryParameter["AudioStreamIndex"] = audioStreamIndex;
            }
            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter["SubtitleStreamIndex"] = subtitleStreamIndex;
            }
            if (volumeLevel !== undefined) {
                localVarQueryParameter["VolumeLevel"] = volumeLevel;
            }
            if (playMethod !== undefined) {
                localVarQueryParameter["PlayMethod"] = playMethod;
            }
            if (liveStreamId !== undefined) {
                localVarQueryParameter["LiveStreamId"] = liveStreamId;
            }
            if (playSessionId !== undefined) {
                localVarQueryParameter["PlaySessionId"] = playSessionId;
            }
            if (repeatMode !== undefined) {
                localVarQueryParameter["RepeatMode"] = repeatMode;
            }
            if (subtitleOffset !== undefined) {
                localVarQueryParameter["SubtitleOffset"] = subtitleOffset;
            }
            if (playbackRate !== undefined) {
                localVarQueryParameter["PlaybackRate"] = playbackRate;
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = new URLSearchParams(query).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof body !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : body || "";
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PlaystateServiceApiAxiosParamCreator = PlaystateServiceApiAxiosParamCreator;
/**
 * PlaystateServiceApi - functional programming interface
 * @export
 */
const PlaystateServiceApiFp = function (configuration) {
    return {
        /**
         * Requires authentication as user
         * @summary Marks an item as unplayed
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersByUseridPlayeditemsById(userId, id, options) {
            const localVarAxiosArgs = await (0, exports.PlaystateServiceApiAxiosParamCreator)(configuration).deleteUsersByUseridPlayeditemsById(userId, id, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that a user has stopped playing an item
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {string} nextMediaType The next media type that will play
         * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms
         * @param {string} [liveStreamId]
         * @param {string} [playSessionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersByUseridPlayingitemsById(userId, id, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options) {
            const localVarAxiosArgs = await (0, exports.PlaystateServiceApiAxiosParamCreator)(configuration).deleteUsersByUseridPlayingitemsById(userId, id, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports playback has started within a session
         * @param {PlaybackStartInfo} body PlaybackStartInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsPlaying(body, options) {
            const localVarAxiosArgs = await (0, exports.PlaystateServiceApiAxiosParamCreator)(configuration).postSessionsPlaying(body, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Pings a playback session
         * @param {string} [playSessionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsPlayingPing(playSessionId, options) {
            const localVarAxiosArgs = await (0, exports.PlaystateServiceApiAxiosParamCreator)(configuration).postSessionsPlayingPing(playSessionId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports playback progress within a session
         * @param {PlaybackProgressInfo} body PlaybackProgressInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsPlayingProgress(body, options) {
            const localVarAxiosArgs = await (0, exports.PlaystateServiceApiAxiosParamCreator)(configuration).postSessionsPlayingProgress(body, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports playback has stopped within a session
         * @param {PlaybackStopInfo} body PlaybackStopInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsPlayingStopped(body, options) {
            const localVarAxiosArgs = await (0, exports.PlaystateServiceApiAxiosParamCreator)(configuration).postSessionsPlayingStopped(body, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates userdata for an item
         * @param {UserItemDataDto} body UserItemDataDto:
         * @param {string} userId User Id
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersByUseridItemsByItemidUserdata(body, userId, itemId, options) {
            const localVarAxiosArgs = await (0, exports.PlaystateServiceApiAxiosParamCreator)(configuration).postUsersByUseridItemsByItemidUserdata(body, userId, itemId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Marks an item as played
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} [datePlayed] The date the item was played (if any). Format &#x3D; yyyyMMddHHmmss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersByUseridPlayeditemsById(userId, id, datePlayed, options) {
            const localVarAxiosArgs = await (0, exports.PlaystateServiceApiAxiosParamCreator)(configuration).postUsersByUseridPlayeditemsById(userId, id, datePlayed, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that a user has begun playing an item
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {boolean} [canSeek] Indicates if the client can seek
         * @param {number} [audioStreamIndex]
         * @param {number} [subtitleStreamIndex]
         * @param {string} [playMethod]
         * @param {string} [liveStreamId]
         * @param {string} [playSessionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersByUseridPlayingitemsById(userId, id, mediaSourceId, canSeek, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, options) {
            const localVarAxiosArgs = await (0, exports.PlaystateServiceApiAxiosParamCreator)(configuration).postUsersByUseridPlayingitemsById(userId, id, mediaSourceId, canSeek, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports a user's playback progress
         * @param {MediaEncodingApiOnPlaybackProgress} body OnPlaybackProgress
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms
         * @param {boolean} [isPaused] Indicates if the player is paused.
         * @param {boolean} [isMuted] Indicates if the player is muted.
         * @param {number} [audioStreamIndex]
         * @param {number} [subtitleStreamIndex]
         * @param {number} [volumeLevel] Scale of 0-100
         * @param {string} [playMethod]
         * @param {string} [liveStreamId]
         * @param {string} [playSessionId]
         * @param {string} [repeatMode]
         * @param {number} [subtitleOffset]
         * @param {number} [playbackRate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersByUseridPlayingitemsByIdProgress(body, mediaSourceId, userId, id, positionTicks, isPaused, isMuted, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, subtitleOffset, playbackRate, options) {
            const localVarAxiosArgs = await (0, exports.PlaystateServiceApiAxiosParamCreator)(configuration).postUsersByUseridPlayingitemsByIdProgress(body, mediaSourceId, userId, id, positionTicks, isPaused, isMuted, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, subtitleOffset, playbackRate, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
exports.PlaystateServiceApiFp = PlaystateServiceApiFp;
/**
 * PlaystateServiceApi - factory interface
 * @export
 */
const PlaystateServiceApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Requires authentication as user
         * @summary Marks an item as unplayed
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByUseridPlayeditemsById(userId, id, options) {
            return (0, exports.PlaystateServiceApiFp)(configuration)
                .deleteUsersByUseridPlayeditemsById(userId, id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports that a user has stopped playing an item
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {string} nextMediaType The next media type that will play
         * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms
         * @param {string} [liveStreamId]
         * @param {string} [playSessionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByUseridPlayingitemsById(userId, id, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options) {
            return (0, exports.PlaystateServiceApiFp)(configuration)
                .deleteUsersByUseridPlayingitemsById(userId, id, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports playback has started within a session
         * @param {PlaybackStartInfo} body PlaybackStartInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlaying(body, options) {
            return (0, exports.PlaystateServiceApiFp)(configuration)
                .postSessionsPlaying(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Pings a playback session
         * @param {string} [playSessionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlayingPing(playSessionId, options) {
            return (0, exports.PlaystateServiceApiFp)(configuration)
                .postSessionsPlayingPing(playSessionId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports playback progress within a session
         * @param {PlaybackProgressInfo} body PlaybackProgressInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlayingProgress(body, options) {
            return (0, exports.PlaystateServiceApiFp)(configuration)
                .postSessionsPlayingProgress(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports playback has stopped within a session
         * @param {PlaybackStopInfo} body PlaybackStopInfo:
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlayingStopped(body, options) {
            return (0, exports.PlaystateServiceApiFp)(configuration)
                .postSessionsPlayingStopped(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Updates userdata for an item
         * @param {UserItemDataDto} body UserItemDataDto:
         * @param {string} userId User Id
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridItemsByItemidUserdata(body, userId, itemId, options) {
            return (0, exports.PlaystateServiceApiFp)(configuration)
                .postUsersByUseridItemsByItemidUserdata(body, userId, itemId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Marks an item as played
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} [datePlayed] The date the item was played (if any). Format &#x3D; yyyyMMddHHmmss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridPlayeditemsById(userId, id, datePlayed, options) {
            return (0, exports.PlaystateServiceApiFp)(configuration)
                .postUsersByUseridPlayeditemsById(userId, id, datePlayed, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports that a user has begun playing an item
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {boolean} [canSeek] Indicates if the client can seek
         * @param {number} [audioStreamIndex]
         * @param {number} [subtitleStreamIndex]
         * @param {string} [playMethod]
         * @param {string} [liveStreamId]
         * @param {string} [playSessionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridPlayingitemsById(userId, id, mediaSourceId, canSeek, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, options) {
            return (0, exports.PlaystateServiceApiFp)(configuration)
                .postUsersByUseridPlayingitemsById(userId, id, mediaSourceId, canSeek, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports a user's playback progress
         * @param {MediaEncodingApiOnPlaybackProgress} body OnPlaybackProgress
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms
         * @param {boolean} [isPaused] Indicates if the player is paused.
         * @param {boolean} [isMuted] Indicates if the player is muted.
         * @param {number} [audioStreamIndex]
         * @param {number} [subtitleStreamIndex]
         * @param {number} [volumeLevel] Scale of 0-100
         * @param {string} [playMethod]
         * @param {string} [liveStreamId]
         * @param {string} [playSessionId]
         * @param {string} [repeatMode]
         * @param {number} [subtitleOffset]
         * @param {number} [playbackRate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridPlayingitemsByIdProgress(body, mediaSourceId, userId, id, positionTicks, isPaused, isMuted, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, subtitleOffset, playbackRate, options) {
            return (0, exports.PlaystateServiceApiFp)(configuration)
                .postUsersByUseridPlayingitemsByIdProgress(body, mediaSourceId, userId, id, positionTicks, isPaused, isMuted, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, subtitleOffset, playbackRate, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.PlaystateServiceApiFactory = PlaystateServiceApiFactory;
/**
 * PlaystateServiceApi - object-oriented interface
 * @export
 * @class PlaystateServiceApi
 * @extends {BaseAPI}
 */
class PlaystateServiceApi extends base_1.BaseAPI {
    /**
     * Requires authentication as user
     * @summary Marks an item as unplayed
     * @param {string} userId User Id
     * @param {string} id Item Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    deleteUsersByUseridPlayeditemsById(userId, id, options) {
        return (0, exports.PlaystateServiceApiFp)(this.configuration)
            .deleteUsersByUseridPlayeditemsById(userId, id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports that a user has stopped playing an item
     * @param {string} userId User Id
     * @param {string} id Item Id
     * @param {string} mediaSourceId The id of the MediaSource
     * @param {string} nextMediaType The next media type that will play
     * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms
     * @param {string} [liveStreamId]
     * @param {string} [playSessionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    deleteUsersByUseridPlayingitemsById(userId, id, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options) {
        return (0, exports.PlaystateServiceApiFp)(this.configuration)
            .deleteUsersByUseridPlayingitemsById(userId, id, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports playback has started within a session
     * @param {PlaybackStartInfo} body PlaybackStartInfo:
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    postSessionsPlaying(body, options) {
        return (0, exports.PlaystateServiceApiFp)(this.configuration)
            .postSessionsPlaying(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Pings a playback session
     * @param {string} [playSessionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    postSessionsPlayingPing(playSessionId, options) {
        return (0, exports.PlaystateServiceApiFp)(this.configuration)
            .postSessionsPlayingPing(playSessionId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports playback progress within a session
     * @param {PlaybackProgressInfo} body PlaybackProgressInfo:
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    postSessionsPlayingProgress(body, options) {
        return (0, exports.PlaystateServiceApiFp)(this.configuration)
            .postSessionsPlayingProgress(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports playback has stopped within a session
     * @param {PlaybackStopInfo} body PlaybackStopInfo:
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    postSessionsPlayingStopped(body, options) {
        return (0, exports.PlaystateServiceApiFp)(this.configuration)
            .postSessionsPlayingStopped(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Updates userdata for an item
     * @param {UserItemDataDto} body UserItemDataDto:
     * @param {string} userId User Id
     * @param {string} itemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    postUsersByUseridItemsByItemidUserdata(body, userId, itemId, options) {
        return (0, exports.PlaystateServiceApiFp)(this.configuration)
            .postUsersByUseridItemsByItemidUserdata(body, userId, itemId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Marks an item as played
     * @param {string} userId User Id
     * @param {string} id Item Id
     * @param {string} [datePlayed] The date the item was played (if any). Format &#x3D; yyyyMMddHHmmss
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    postUsersByUseridPlayeditemsById(userId, id, datePlayed, options) {
        return (0, exports.PlaystateServiceApiFp)(this.configuration)
            .postUsersByUseridPlayeditemsById(userId, id, datePlayed, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports that a user has begun playing an item
     * @param {string} userId User Id
     * @param {string} id Item Id
     * @param {string} mediaSourceId The id of the MediaSource
     * @param {boolean} [canSeek] Indicates if the client can seek
     * @param {number} [audioStreamIndex]
     * @param {number} [subtitleStreamIndex]
     * @param {string} [playMethod]
     * @param {string} [liveStreamId]
     * @param {string} [playSessionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    postUsersByUseridPlayingitemsById(userId, id, mediaSourceId, canSeek, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, options) {
        return (0, exports.PlaystateServiceApiFp)(this.configuration)
            .postUsersByUseridPlayingitemsById(userId, id, mediaSourceId, canSeek, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports a user's playback progress
     * @param {MediaEncodingApiOnPlaybackProgress} body OnPlaybackProgress
     * @param {string} mediaSourceId The id of the MediaSource
     * @param {string} userId User Id
     * @param {string} id Item Id
     * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms
     * @param {boolean} [isPaused] Indicates if the player is paused.
     * @param {boolean} [isMuted] Indicates if the player is muted.
     * @param {number} [audioStreamIndex]
     * @param {number} [subtitleStreamIndex]
     * @param {number} [volumeLevel] Scale of 0-100
     * @param {string} [playMethod]
     * @param {string} [liveStreamId]
     * @param {string} [playSessionId]
     * @param {string} [repeatMode]
     * @param {number} [subtitleOffset]
     * @param {number} [playbackRate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    postUsersByUseridPlayingitemsByIdProgress(body, mediaSourceId, userId, id, positionTicks, isPaused, isMuted, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, subtitleOffset, playbackRate, options) {
        return (0, exports.PlaystateServiceApiFp)(this.configuration)
            .postUsersByUseridPlayingitemsByIdProgress(body, mediaSourceId, userId, id, positionTicks, isPaused, isMuted, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, subtitleOffset, playbackRate, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.PlaystateServiceApi = PlaystateServiceApi;
//# sourceMappingURL=playstate-service-api.js.map